# Forms

One of the problems with HTML 4 forms is that they're just dumb fields. Validation is required on the server, of course, but you have to duplicate it in the user's browser with JavaScript to give them the seamless experience they deserve. Given that almost every web page has some kind of form--search, comments, sign-up, and so on--wouldn't it be great if browsers had built-in validation for some of the most common data types that we collect?

You guessed it: HTML5 forms provide exactly that.

## We &hearts; HTML, and now it &hearts;s us back

> These form enhancements aren't implemented across the board yet. Opera has the most extensive support, followed by the WebKit browsers and Firefox. At the time of this writing, Internet Explorer 10 Platform Preview 2 has some support. Exciting times!

HTML5 makes developing forms quicker. There are some nice goodies like the addition of two HTTP types of form action (`update` and `delete`) to go with the current `get` and `post`. But the coolest features for developers--which will be transparent to bosses and consumers, but they'll make our lives much easier-- are new form input types which can give us special UIs and built-in error reporting.

Eventually, you won't need JavaScript validation at all for these fundamental data types, although you can't mothball your scripts yet--the new input types degrade gracefully but will need your JavaScript until the golden future when everyone has an HTML5 browser (or your boss tells you that users of ancient browsers will just have to put up with server-side-only form checking). In Chapter 12, we show you a methodology called *polyfilling* to ensure that old browsers (and only old browsers) are given a JavaScript helping hand, while you just code to the standard.

## New input types

The new form fields were the genesis of the spec that became HTML5, and this is where we see the principle of specifying backwards-compatible extensions to the language in action. The extensions are largely new values of the type attribute of the input element. HTML4 specifies that browsers should assume `<input type=text>` if you don't specify a type attribute, or you use an unknown type. Therefore, legacy browsers that don't understand the new extensions will fall back to the default and allow the user to enter data in a plain text field. This fallback can be detected in script and polyfilled if required so old browsers can mimic the new behaviours.

The specification makes no requirements on how browsers should present the new input types to the user or report errors, and so on. Different browsers and different devices will present different user interfaces; compare, for example, the different ways that a select box is shown in Safari on a desktop and an iPhone (Figure 3.1).

{{figure 3.1
Figure 3.1 The same select box rendered in Safari/Windows (left) and Safari/iPhone (right).
}}

The manner in which the browser reports errors is similarly undefined. Figure 3.2 shows errors generated when a required field isn't completed before submission in Opera, Firefox, and Google Chrome. Below, you can see the same error in the Japanese localised Opera. Because the messages are part of the browser, they are automatically localised, meaning much less work for a developer and a more usable experience for the consumer.

{{figure 3.2
Figure 3.2 Automatically generated error messages in Opera, Firefox, Chrome, and Japanese Opera (below).
}}


### The email input type

The markup `<input type=email>` tells the browser that it should not allow the form to be submitted if the user has not entered what looks like a valid email address--that is, it doesn't check whether the email address exists or not, only whether it's in a valid format. As with all input types, the user may submit the form with this field empty unless the required attribute is present.

The multiple attribute indicates that the value of the field can be a list of comma-separated, valid email addresses. This does not require that the user enter a comma-separated list manually; a browser may choose to pop up a list of the user's contacts from his mail client or phone contacts list, with checkboxes and then construct the comma-separated list behind the scenes.

Currently browsers aren't this helpful, but because this type is now unambiguous and machine readable/understandable, the browser knows what the intention of the author is and can conceivably offer more contextually-relevant UI. For example, the experimental [Firefox Contacts add-on](http://mozillalabs.com/blog/2010/03/contacts-in-the-browser) collects contacts from various sources, which it uses to offer addresses when a user comes across an `<input type=email>`. Through the W3C draft [Contacts API](http://dev.w3.org/2009/dap/contacts/), it also exposes this contact information to website scripts.

### The URL input type

`<input type=url>` causes the browser to ensure that the value entered in the field is a correct URL. A browser may offer assistance to the user--for example, Opera automatically prepends "http://" to URLs that don't have a protocol (that is, the user didn't type in http:// or ftp:// or whatever). A URL need not be a web URL; the page could, for example, be a webbased HTML editor in which the user may wish to use the tel: pseudo-protocol.

### The date input type

The option `<input type=date>` is one of my favourites. We've all seen web pages that require the user to enter a date for a flight, concert ticket, and the like. Because dates are tricky to enter (is the format DD-MM-YYYY or MM-DD-YYYY or YYYY-MM-DD?), developers code JavaScript date picker widgets that vary wildly in appearance, usability, and accessibility between sites.

Using `<input type=date>` solves this problem by providing a native datepicker widget that's rendered directly by the browser. Opera, for example, pops up a calendar widget (Figure 3.3).

On the BlackBerry browser in BlackBerry Device Software version 5.0, the date input control used to implement the date input field is the same Java component used within the native BlackBerry calendar app (although it isn't integrated with the calendar app). See Figure 3.4.

{{figure 3.3
Figure 3.3 Opera renders a calendar widget.
}}

{{figure 3.4
Figure 3.4 `<input type=date>` on the BlackBerry browser.}}

Of course, these are still early days. In the future, though, it's conceivable that, beyond simply showing a shiny new datepicker, the browser could do something far cleverer, and call up the native calendar app so you could browse dates to see your prior appointments. The point is that the browser can now understand what you mean. Previously, date pickers were--from the perspective of the browser--nothing more than `<div>`s, `<span>`s, and links with lots of JavaScript behaviour attached. Now the browser knows that you're in fact entering an actual time and date and can offer richer controls and integration with other time/date information.

### The time input type

`<input type=time>` allows input of a time in 24-hour format and validates it. Once again, the actual user interface is left to the browser; it could be as simple as entering numbers and throwing an error if the user enters an hour greater than 24 or one minute greater than 59, or it could be far more elaborate: a clock face, for example, with draggable hands. The user interface could also allow for entry of a time zone offset.

### The datetime input type

Date and time that we've just seen can be combined using `<input type=datetime>` to validate a precise date and time. Local date and time works as datetime except that the browser doesn't allow the user to add (or change) a time zone offset.

{{figure 3.5
Figure 3.5 Opera's rendering of `<input type=week>`.
}}

### The month input type

Using `<input type=month>` allows entry and validation of a month. Although the month value is stored internally as a number between 1 and 12, the browser may offer a selection method that uses the names of the months instead. You could do this with a select box with 12 options, January to December, but this doesn't localise. Using an HTML5 month input type, a French-localisation of a browser could offer a drop-down with Janvier instead of January, for example. That's more work for the browser and less work for web developers, and that's the way it should be.

### The week input type

`<input type=week>` allows entry and validation of a week number. While this could be a simple input field allowing a user to input a number, it's more complex in practice: some years have 53 weeks. Therefore, the format is 2010-W07 for the seventh week in the year 2010.

Opera offers a date picker UI, which populates the input field with the week number of any selected date rather than the dates YYYY-MM-DD format (Figure 3.5).

### The number input type

Not surprisingly, `<input type=number>` validates numeric entry. It is not meant for telephone numbers, as these are often typed with spaces, brackets, plus signs, hyphens etc; use `<input type=tel>` for those.

{{figure 3.6
Figure 3.6 Opera (left) and Chrome (right) rendering `<input type=number>`.
}}

It works perfectly with the min, max, and step attributes (see below). In Opera and Chrome, it is rendered as a spinner control that will not go beyond the upper and lower limits (if specified) and which progresses by the increment specified in step, although a user can also type the value (Figure 3.6). The spin controls are outside the input area in Opera, and inside the input area in Chrome. The spec is rightly unprescriptive on the UI of these new controls.

There's a nasty gotcha on desktop browsers that don't offer a special, numeric-only UI. Currently, typing alphabetic characters into type=number fields doesn't throw a validation error in Opera or Chrome. This seems to me to be highly counter-intuitive behavior. It's because the browser doesn't get as far as validating the input, as it never even replaces the current value of the field with the non-numeric characters that you typed. Unfortunately, the UI suggests that you've entered alphabetics and they've been accepted.

### The range input type

Using `<input type=range>` renders as a slider. Figure 3.7 shows it in Chrome.

Previously, sliders needed to be faked by hijacking an input and using JavaScript and images for the pointers. Because these were not native in the browser, great care had to be taken--and extra code written--to ensure keyboard accessibility. Now that sliders are native to HTML, the responsibility is removed from the developer, leading to leaner code and greater accessibility for keyboard users.

See the example in the "Putting all this together" section of this chapter for more information. It works perfectly with the min, max, and step attributes (see below).

{{figure 3.7
Figure 3.7 Chrome's rendering of `<input type=range>`.
}}

### The search input type

This input type, `<input type=search>`, expects a search term.

In Safari there is also an unspecified proprietary attribute that adds a history of recent results, using the `results=n` attribute. The difference between search and text type is only stylistic, and in Safari on the Mac, it takes the operating system's default rounded-corners style for search--which can nonetheless be overwritten with some proprietary CSS (hat-tip to Wilfred Nas for this):

```html
input[type="search"] {
  -webkit-appearance: textfield;
}
```

### The tel input type

`<input type=tel>` expects a telephone number. There is no special validation; it doesn't even enforce numeric-only input, as many phone numbers are commonly written with extra characters, for example +44 (0) 208 123 1234.

As mobile phones "know" their own number, we expect that most mobile phones will be able to do things like autocompleting these entry fields. None currently do this, although the iPhone brings up a telephone number input screen (Figure 3.8).

{{figure 3.8
Figure 3.8 The iPhone's keypad for completing `<input type=tel>`.
}}


### The color input type

`<input type=color>`allowstheusertoinputacolourvalueviaa picker. So far, it's only implemented on the BlackBerry (Figure 3.9) and Opera.

{{figure 3.9
Figure 3.9 `<input type=color>` on the BlackBerry.
}}


{{aside

# Don't forget the name attribute!

Just because new client-side validation is built into browsers, don't forget to give your input fields (and groups of radio buttons) unique values for the name attribute, because that's how you access these values on the server that the form submits to. Older versions of Opera require this before the new HTML5 validation is performed, as that's what the spec said at the time.

As older versions of IE can get the id and name tangled up when you do __getElementByID__, we recommend using the same unique value for the id and name of each field, thereby making your form more accessible, too:

```html
<label for=f-email>Email address</label>
<input id=f-email name=f-email type=email>
```

}}

## New attributes

As well as new input types, the `<input>` element has several new attributes to specify behaviour and constraints: autocomplete, min, max, multiple, pattern, and step. There's also a new attribute, list, that hooks up with a new element to allow a new data input method.

### The list attribute and `<datalist>`

The combination of an `<input>` with a list attribute and a `<datalist>` is a combo box--a combination of a drop-down list and a single-line textbox, that allows users to enter their own text if they don't want to choose one of the predefined options.

The list is contained in a new `<datalist>` element, the id of which is referenced in the value of the list attribute:

```html
<input id=form-person-title type=text list=mylist>
<datalist id=mylist>
  <option label=Mr value=Mr>
  <option label=Ms value=Ms>
  <option label=Prof value="Mad Professor">
</datalist>
```

`<datalist>` has no rendering of its own, but instead shows up as values in a select-like field.

The previous example uses type=text to allow free-form input, but you can use `<datalist>` with url and email.

Many have asked why the `<input>`/`<datalist>` pair isn't combined into a single new element like `<select>` is. The answer lies with backwards compatibility: the `<input>`/`<datalist>` pairing degrades to `<input type=text>` in legacy browsers, so the user can at least enter something, and so you can easily fake the full implementation with JavaScript for those browsers as well.

Jeremy Keith has a good example of this backwards compatibility at[ http://adactio.com/journal/4272/](http://adactio.com/journal/4272/) (reproduced with his permission):

```html
<label for="source">How did you hear about us?</label>
<datalist id="sources">
  <select name="source">
    <option>please choose...</option>
    <option value="Television">Television</option>
    <option value="Radio">Radio</option>
    <option value="Newspaper">Newspaper</option>
    <option>Other</option>
  </select>
If other, please specify:
</datalist>
<input id="source" name="source" list="sources">
```

Notice how we've wrapped the `<option>` elements in an additional `<select>`, making the contents of the datalist mimic the markup of an old-school dropdown selection. Browsers that understand `<datalist>` will ignore anything other than `<option>` elements, so the nested `<select>` is invisible to them. The text "If other, please specify" is also ignored. Nonconforming browsers, on the other hand, don't see the `<datalist>` element, and will instead fall back to showing what they see as a standard `<select>`. They also display the "If other" text and the input field that the datalist is attached to.

{{figure 3.10
Figure 3.10 `<datalist>` in Opera (top) and gracefully degrading in Safari (bottom).
}}

In other words, browsers that understand `<datalist>` see each `<option>` as being part of the datalist, and see nothing else. Browsers that don't support `<datalist>` see each `<option>` as being part of a `<select>` and see the additional text "If other, please specify," and the input that is hooked onto the datalist via the list attribute degrades to a simple text input field (Figure 3.10).

This is an excellent pattern that will become part of your day-today form-coding arsenal--unless the Working Group decides to take it away from us, see Note!

Like me, this ain't pretty, but it does work (although not so far in IE10 Platform Preview 2, where it degrades into the select + input) and it demonstrates how the new features can degrade gracefully.

### The autofocus attribute

The `autofocus` boolean provides a declarative way to focus a form control when a page is loaded. Previously, a developer had to write JavaScript that triggered the control's `focus()` method onload. Now the browser can do clever things like not actually focusing the control if the user is already typing elsewhere (a common problem of old-school JavaScript onload focus scripts).

There should be only one such input field on a page. From a usability perspective, this attribute should be used with care. We recommend only using it on pages that have a form field as their central purpose--a search form page, for example.

> The Working Group is considering removing this method of graceful degradation through markup, on the somewhat shaky grounds that web authors don't use it much and it's hard to specify and implement (what to do about `<script>` elements inside a `<datalist>`?)

> If it is removed, we'll note it on [www.introducinghtml.com](http://www.introducinghtml.com) and you'll have to rely on scripting to make `<datalist>` degradable in older browsers. Which would be a shame.

### The placeholder attribute

A usability trick employed regularly by developers is placing text in an input field as a hint for the user, removing the text when the user focuses on the field, and restoring the text when focus leaves the field. This used to require JavaScript. However, it can now be done declaratively with the `placeholder` attribute. The specification says, "For a longer hint or other advisory text, the title attribute is more appropriate."

This is generally rendered in a lighter shade of the input's font colour. It can be styled using `::-webkit-input-placeholder`, `:-moz-placeholder` and `-ms-input-placeholder`. For future compatibility, also add `–o-input-placeholder`. This is experimental and not in the official CSS spec.

It's important to note that placeholder does not replace form `<label>`s.

### The required attribute

The new `required` attribute can be used on `<textarea>` and most input fields (except when the type attribute is hidden, image, or some button types such as submit). Modern browsers will not allow the user to submit the form if required fields are empty and report an error.

We recommend also adding the ARIA attribute aria-required to such input fields for assistive technology. (See the discussion of ARIA in Chapter 2.)

The multiple attribute `<input type=file>` is not new in HTML5, but when used in conjunction with the new multiple attribute, the user can now upload multiple files:

```html
<input type=file multiple>
```

This was impossible to do in HTML4, so web authors used Java applets or Flash to achieve the same effect: `multiple` can also be used with other input types: for example, `<input type=email multiple>` allows the user to enter commaseparated email addresses.

> If regular expressions scare you but you want to learn more, or you're keen to fuel your regular expression ninja skills, take a gander at [Steven Levithan's blog](http://blog.stevenlevithan.com) which talks about them almost exclusively.

### The pattern attribute

Some of the input types mentioned previously--email, number, url, and so on--are really "baked-in" regular expressions, as the browser just checks if the values entered look like they should.

Suppose you want to match against a different template? The pattern attribute allows you to specify a custom regular expression that the input must match. So, if the user must always enter a single digit plus three uppercase alphabetic characters, the regular expression would be one number `[0–9]` and three letters `[A–Z]{3}`, all in uppercase, and the input would be coded

```html
<input pattern="[0-9][A-Z]{3}" name=part title="A part number is a digit followed by three uppercase letters.">
```

You could also add a `placeholder="1ABC"` or something similar as a short hint.

The specification explains that the regular expressions in the pattern attribute match the syntax of regular expressions in JavaScript, except that there's an implied `^(:?` at the beginning and `)$` at the end.

So if you're accustomed to working with regular expressions, you're already familiar with what you need to do. If not, you've got the fun world of regular expressions to explore!

The Internet is littered with JavaScript regular expressions that match this, that, and the other, so it's likely that you'll find what you're looking for. However, regular expressions, when kept simple, are relatively easy to get working.

For example, to match a ZIP code in the format of 99999 or 99999-9999 (assuming the 9s are all kinds of numbers), you can use:

```html
<input pattern="[0-9]{5}(\-[0-9]{4})?" title="A zip code in the format of 99999 or 99999-9999">
```

This regular expression looks for a numerical sequence of five, with an optional suffix of a dash followed by another sequence of four numbers.

We could extend this pattern to also validate UK post codes (using a simplified post code match):

```html
<input required pattern="[0-9]{5}(\-[0-9]{4})?|[a-zA-Z] {1,2}\d{1,2}\s?\d[a-zA-Z]{1,2}" name=part title="A valid zip code or UK postcode">
```

Now our regular expression has become much more complicated and it can be quite tricky to test this pattern on a big form in a web page. Since the pattern's regular expression matches the syntax of a JavaScript regular expression, we can test this in a browser console such as Firebug or Opera Dragonfly, using pure JavaScript to determine whether the pattern will work. In the example below, I'm just testing the UK post code match, and using the JavaScript test method to experiment. Note that I've also wrapped my tests with the leading `^(:?` and trailing `)$` as the HTML5 spec states:

```js
/^(:?[a-zA-Z]{1,2}\d{1,2}\s?\d[a-zA-Z]{1,2})$/.test("bn14 8px");
> true
/^(:?[a-zA-Z]{1,2}\d{1,2}\s?\d[a-zA-Z]{1,2})$/.test("bn149 8px");
> false
```

Those results are correct, since "bn149" isn't a legal part of a post code (or certainly not for this contrived example!). Finally, it's worth noting that the pattern attribute is case sensitive, and since we have no way to switch to case insensitive mode, we need to match on lowercase and uppercase explicitly in this example (hence the `[a-zA-Z]`).

### The autocomplete attribute

Most browsers have some kind of `autocomplete` functionality. HTML has an autocomplete attribute which lets you control how this works. Although it's newly standardized in HTML5, it's not a new feature; it was a non-standard feature of IE5.

The default state is for the input to inherit the autocomplete state of its form owner. Forms have autocomplete on by default.

If the autocomplete attribute of a form element is set to on, the field is fine for autocompletion.

I'll quote the wry humour of the specification's description of the off state: "The off state indicates either that the control's input data is particularly sensitive (for example, the activation code for a nuclear weapon); or that it is a value that will never be reused (for example, a one-time-key for a bank login) and the user will therefore have to explicitly enter the data each time."

### The min and max attributes

As we've seen with `<input type=number>`, these min and max attributes constrain the range of values that can be entered in an input; you can't submit the form with a number smaller than min or larger than max. But they can also be used with other input types--for example, `<input type=date min=2010-01-01 max=2010-12-31>` will only accept a date that's in the year 2010. It's trivial to make the server write HTML that has a min of today, so only future days are allowed (for a flight booking site, for example) or a max of today (for a field collecting date of birth, for example).

### The step attribute

The step attribute controls the level of granularity of input. So if you want the user to enter a percentage between 0 and 100, but only to the nearest 5, you can specify and the spinner control will increment in steps of 5.

```html
<input type=number mix=0 max=100 step=5>
```

Taking the example of a time control, you can also use `step=any`. This allows any time in the day to be selected, with any accuracy (for example, thousandth-of-a-second accuracy or more); normally, time controls are limited to an accuracy of one minute.

```html
<input name=favtime type=time step=any>
```

### The form attribute

Traditionally, form controls all needed to be inside a `<form>` element. If, for whatever reason--design, styling, or the like-- authors wanted to have a form somewhere on the page and some other related controls somewhere else, they would (in the worst case) wrap the entire page up in a form element.

But--brave new world!--in HTML5, a number of elements that were previously required to be within a form element (`<button>`, `<fieldset>`, `<input>`, `<label>`, `<select>`, `<textarea>`, plus `<object>` and the new elements like `<keygen>`, `<meter>`, `<output>`, and `<progress>`) can now be anywhere on the page and associated with a form using a form attribute pointing at the id of its form owner.

Consider this example:

```html
<form id=foo>
  <input type="text">
  ...
</form>
<textarea form=foo></textarea>
```

The `<input>` is owned by the form foo, as it is contained within it and does not have a form attribute overriding that ownership. The `<textarea>` is outside the form, but is still owned by it, as its form attribute points to the id of its form owner.

This gives a lot more flexibility with styling when you want those elements to appear visually (and structurally) outside the parent forms.

The form attribute is supported in Opera, Firefox, and Chrome. As Safari shares a codebase with Chrome, it's likely to appear there soon, too. IE has no support currently, and at the time of writing, none has been announced for IE10.

## `<progress>`, `<meter>` elements

The `<progress>` element is used to represent a "progress meter," to indicate the completion of a task--downloading a file, for example. It has two attributes: max, which specifies how much work the task requires in total, and value, which specifies how much of the task has been completed. The units are arbitrary and not specified:

```html
<progress value=5 max=20>5</progress>
```

In supporting browsers, this is replaced with a progress meter graphic (Figure 3.11).

{{figure 3.11
Figure 3.11 `<progress>` in Chrome (left) and Opera (right). Chrome's progress meter is slightly animated; Opera's is static.
}}

`<meter>` is very similar (many have questioned whether there needs to be two separate elements at all). The spec says that `<meter>` "represents a scalar measurement within a known range, or a fractional value; for example disk usage, the relevance of a query result, or the fraction of a voting population to have selected a particular candidate."

It takes the following floating-point attributes:

- value--the "measured" value shown by meter
- min--the lower bound of the range for the meter
- low--the point that marks the upper boundary of the "low" segment of the meter
- high--the point that marks the lower boundary of the "high" segment of the meter
- max--the upper bound of the range for the meter
- optimum--the point that marks the "optimum" position for the meter

Only value is required. If min and max are missing, the range 0 to 1 is assumed Opera and Chrome (the two browsers that support `<progress>` and `<meter>` at the time of this writing) colour the meter differently if the value is between the low to high values.

In older browsers, the text content of the elements is displayed as fallback content.

## Putting all this together

It's pretty confusing to work out which attributes go with which input types when you're meeting them all at once as we are here. But it's actually quite straightforward when you start using them. For example, you can't use min and max on a `<textarea>`, because that wouldn't make sense, but you can use required.

### A blog comments form

Let's look at a classic form example that most of us are already familiar with. Nearly all blogs have a comment section, with fields for the commenter's name (required), her email address (required), URL (optional), and the comment (required). That would need a fair bit of JavaScript if we were to do our form validation by hand.

In HTML5, however, we need only use some new form types. We also add a submit button--currently browsers only show validation messages when a form is actually submitted.

```html
<form>
  <label for=form-name>Name</label>
  <input name=form-name id=form-name type=text required>
  <label for=form-email>Email</label>
  <input name=form-email id=form-email type=email required>
  <label for=form-url>URL</label>
  <input name=form-url id=form-url type=url>
  <label for=form-comment>Comment</label>
  <textarea name=form-comment id=form-comment required></textarea>
  <input type=submit>
</form>
```

Hey, Presto! We now have a sexy comment form that validates user input...no JavaScript required!

### A slider, with scripted output

We've seen `<input type=range>` earlier in this chapter. Notice that, by default, browsers show the slider, but don't give any indication of the minimum, maximum, or current value of the slider, so let's code up an example that actually shows the user the range allowed by the slider by automatically indicating the minimum and maximum values, and dynamically outputting the slider's current value.

The slider will go from 1 to 11, as all good controls should (be they for guitar amps or otherwise). The step will be 1, which is the default, so we can omit that attribute:

```html
<input type=range min=1 max=11 name=tap>
```

To show the user the minimum and maximum values, we can use generated content (which doesn't work on sliders in WebKit browsers):

```css
input[type=range]::before {
  content: attr(min);
}

input[type=range]::after {
  content: attr(max);
}
```

This will show the values, and style them as defined in CSS. For example, Figure 3.12 renders:

```css
input[type=range] {
  width:500px;
  color:red;
  font-family: cursive;
  font: -size:2em;
}
```

{{figure 3.12
Figure 3.12 Opera's rendering of `<input type=range>` with min and max values generated.
}}

We'll echo the current value of the slider with the new output element.

### The `<output>` element

The `<output>` element is for showing results of some calculation or other with script. It can have a form owner, either by being inside a form or via a form attribute. The new `<progress>` and `<meter>` elements discussed earlier can be similarly associated with a form to provide feedback to the user.

We tie it to the slider by the name of the slider (`name=tap`), and use the oninput event on the containing form. When the output's form owner receives input (as the slider is moved), we'll echo back the value of that input:

```html
<!-- this example assumes variable output contains
     the DOM output element and the variable slider
     contains the DOM input range element -->
<form oninput="output.value=slider.value">
  <input id=slider type=range min=1 max=5 value=5>
  <output id=output>5</output>
</form>
```

> The first edition of this book used `onforminput` rather than the oninput event, but that's deprecated. Markup history buffs can read [useragentman's post](http://www.useragentman.com/blog/2011/05/10/is-onforminput-deprecated-in-html5-forms-and-why-should-i-care-anyways/) for more.


The actual contents of the output element (in this case, "5") is only there as a starting value, to be shown before the slider is actually changed. In this simple example, we simply put the "5" in the markup, as it's the same starting value as the input type=range. You could, of course, use a script that runs onload and programmatically prefills the output with the value of its associated input.

### Using WAI-ARIA for transitional accessibility

Although we said that `<input type=range>` removed responsibility for accessibility from the developer, that's true only when HTML5 is widely supported and assistive technology understands this new type of form input.

> In the first edition of this book, I added a `role=slider` attribute to tell assistive technology how to map the control to operating system controls. I was wrong, or at least premature. In an ideal world of full browser support (one day, dear reader, one day), this would be fine. But for now, don't do it declaratively; do it in JavaScript after seeing if input type=range is supported. (See the "Backwards compatibility with legacy browsers" section below.) In browsers that don't support type=range, setting it declaratively adds a role of slider on a plain text input which would be wrong and very confusing to an assistive technology user.

During this transitional time, if you want to use HTML5 sliders, add some WAI-ARIA information, which for the time being will result in some duplication:

```html
<input id=tap name=tap type=range min=1 max=11 value=0 aria-valuemin=1 aria-valuemax=11 aria-valuenow=0>
```

Update aria-valuenow with JavaScript when the slider position is changed. In this case, you'll want to bind to the change event on the slider; in our example, we'll just use the onchange attribute. Unfortunately, we can't use the property syntax to update the aria-valuenow value; we have to update the DOM attribute for the value to update correctly:

```html
<input id=tap name=tap type=range min=1
  max=11
  value=0
  aria-valuemin=1
  aria-valuemax=11
  aria-valuenow=0
  onchange="this.setAttribute('aria-valuenow', this.value)">
```

This will update the value of the `aria-valuenow` attribute, and can be tested if you inspect the element using a DOM inspector.

## Backwards compatibility with legacy browsers

The big question is: What can we do for legacy browsers? The answer is that you don't retire your pre-existing JavaScript validation or fancy DHTML datepickers just yet, but you leave them as a fallback after doing some feature detection.

As we've seen before, browsers will fall back to using input type=text whenever they encounter a type that they don't support. So, a legacy browser, faced with input `type=email`, will simply change it to an input `type=text`. This change also happens in the DOM and, by checking the type of the input, we can programmatically determine if the browser supports the new fancy elements, and act accordingly if not.

For instance, to detect whether `<input type=email>` is supported, you can make a new `<input type=email>` with JavaScript, but don't add it to the page. Then, interrogate your new element to find out what its type attribute is. If it's reported back as "email," then the browser supports the new feature--so let it do its work and don't bring in any JavaScript validation. If it's reported back as "text," it's fallen back to the default, indicating that it's not supported. So your code should load an alternative validation library, ideally through a lazy load technique.

```js
var i = document.createElement("input");
i.setAttribute("type", "email");
return i.type !== "text";
```

You can test attributes, too:

```js
return 'autofocus' in document.createElement("input");
```

So what does this buy you? First and foremost, you're making your forms usable and accessible, providing easy entry mechanisms like datepickers and validating user input before it even goes on a roundtrip to the server. Secondly, you're doing it in a resource-friendly way, using the browser's built-in capabilities (if they already understand client-side validation and the new html5 types/attributes) or, for legacy browsers, gracefully patching in support with traditional JavaScript libraries.

See Chapter 12 for a methodology and discussion of how to shoehorn support into older browsers.

## Styling new form fields and error messages

Whenever we present the new intelligent form fields at conferences, someone asks us how to style these new fields and error messages.

You can do some basic styling on most of the new controls: fonts, colours, and the like. With some controls, however, using current CSS is more problematic. For example, with a `type=range` slider, what does color refer to and what would backgroundcolor style? What would border-radius affect? How would you change the colour of the "track" that the slider runs along?

The natural home for adding new CSS hooks for styling form fields is the enticingly named [CSS Basic User Interface Module](http://www.w3.org/TR/css3-ui/). This has been around since 2004 and--now that browsers have caught up with it--this specification is being updated by Tantek Celik.

There already are some useful ideas that you can implement right now--for example, you can use the `:invalid` pseudo-class to style a form field to show that its contents are invalid, so the user gets that feedback immediately, without having to hit submit. This CSS styles invalid form fields with a red border, and valid inputs green:

```css
[input:invalid] {
  border:2px;
  solid red;
}

[input:valid] {
  border: 2px solid green;
}
```

Unfortunately, this presents several usability problems. A required input, for example, is invalid at page load (because it's required but is blank) and therefore the styles will be set, which is off-putting to the user. An input `type=email` will be invalid the moment the user starts typing, until the first character after "@" is entered, because until that time it's not a valid email address.

The mighty Patrick Lauke (one of this book's technical editors) suggests using a combination of `:focus`, to mitigate the problem and only show the styling when the user is interacting with that particular form field:

```css
[input:focus]:invalid {
  border:2px solid red;
}

[input:focus]:valid {
  border: 2px solid green;
}
```

This works, but only for the currently focussed input. We want something more: we want the invalid fields to be styled differently only after users have entered some content.

Because of these problems, Firefox uses an alternative pseudoclass called `–moz-ui-invalid` which provides a much better user experience, as the Mozilla Developer Center describes:

"If the control is valid when the user starts interacting with it, the validity styling is changed only when the user shifts focus to another control. However, if the user is trying to correct a previously flagged value, the control shows immediately when the value becomes valid. Required items have the pseudo-class applied only if the user changes them or attempts to submit an unchanged valid value."

Other pseudo-classes available include `:in-range` and `:out-ofrange` and `:indeterminate` (the latter would apply to a number input with min/max that is currently empty).

While we wait for a fully specified, properly sanctioned way of consistently styling all the other things in all browsers, there are a few vendor-specific tweaks and tricks that can be used. We've already seen Mozilla's ui-invalid, for example. WebKit offers us ways in which to style the validation error message bubbles (see Figure 3.2):


- `::-webkit-validation-bubble{}`
- `::-webkit-validation-bubble-top-outer-arrow{}`
- `::-webkit-validation-bubble-top-inner-arrow{}`
- `::-webkit-validation-bubble-message{}`

Currently, there aren't many cross-browser methods of changing the look and feel of HTML forms. This isn't necessarily a bad thing. Your branding people will, of course, lament that placeholder text isn't in corporate purple and orange. But it's a usability and accessibility win; although it's tempting to style the stuffing out of your form fields, whatever your branding people say, it's better to leave forms as close to the browser defaults as possible. A browser's slider and date pickers will be the same across different sites, making it much more comprehensible to users. It's much better that a date picker on site X looks and behaves the same as a date picker on site Y or site Z.

And, by using native controls rather than faking sliders and date pickers with JavaScript, your forms are much more likely to be accessible to users of assistive technology.

## Overriding browser defaults

Built-in validation messages are great, but what if you want to customise these error messages? What if it's Talk Like a Pirate Day? Perhaps I want to change all the validation messages to speak like an angry pirate, too.

It's possible, with a bit of JavaScript via `setCustomValidity`. However, by setting a custom message, it causes the field to be invalid in the first place, so the workaround is to first set the custom validity to an empty string--clearing any custom error-- perform a validity check manually in the code, and then set the custom message so that it's then presented to the user.

So instead of reading:

*humptydumpty is not a legal email address*

We'll change the validation to read the following in "traditional" pirate speak:

*humptydumpty be not a legal email address*

The `setCustomValidity` method allows me to specify my own validation message:

```html
<!DOCTYPE html>
<title>custom validity</title>
<form>
  <input type=email id=foo name=foo>
  <input type=submit>
</form>
<script>
var email = document.getElementById('foo');
email.form.onsubmit = function () {
  // reset any previously specified custom validity let
  // the browser run its validation logic
  email.setCustomValidity('');

  // now, after the browser tested if the value entered is
  // actually an email address, inject custom validation
  // message if the validation turns out false (i.e. it's
  // not an email address)

  if (!email.validity.valid) {
    email.setCustomValidity(email.value + " be not a legal email address");
  }
};
</script>
```

Figure 3.13 shows a custom validation message.

{{figure 3.13
Figure 3.13 Opera rendering the default validation message for email (left) and our custom "speak like an angry pirate day" validation (right).
}}


Unfortunately, as it stands today, only Opera supports this properly. In fact, it's questionable that the submit event should even fire if the field is invalid. Perhaps we should be listening for the invalid event on the element? But if we set the custom valid message, when the error is corrected, the field remains marked as invalid because we've set our custom error. So it runs the invalid test again, removing the custom error--but at this point the user has to hit submit twice just to get the form to be submitted when there was a corrected error.

In fact, the only appropriate way of setting a custom message is, on every key press to check the validity of the field. Personally, I find this odd that we would have to poll the input element, but in a way, it behaves the same way the :invalid CSS pseudo selector works. So our example from above changes to:

```html
<!DOCTYPE html>
<title>custom validity</title>
<form>
  <input type=email id=foo name=foo>
  <input type=submit>
</form>
<script>
var email = document.getElementById('foo');
email.oninput = function () {
  // reset any previously specified custom validity let
  // the browser run its validation logic
  email.setCustomValidity('');

  // now, after the browser tested if the value entered is
  // actually an email address, inject custom validation
  // message if the validation turns out false (i.e. it's
  // not an email address)

  if (!email.validity.valid) {
    email.setCustomValidity(email.value + " be not a legal¬email address");
  }
};
</script>
```

However, if the way the custom validation messages work isn't your bag, then there is a way to roll your own validation behaviour, to make it feel more integral to your application. When we run __setCustomValidity__ it sets the read-only DOM attribute called __validationMessage__. We can use this if we manage validation ourselves, which we'll look at in the next section.

Note that if you like single-vendor markup, you can override the error messages in Firefox using the proprietary x-moz-errormessage attribute

```html
<input type=email x-moz-errormessage="Please specify a ¬valid email address.">
```

## Using JavaScript for DIY validation

So far we've seen how we can use a little JavaScript to customise the message the user sees when validation errors occur. If you want to spice things up further, you can use JavaScript to completely handle all the validation and feedback to the user.

Using the JavaScript Web Forms API, we can control how we present validation feedback to our visitor, but we can still defer all the actual validation heavy lifting code to the new forms, APIs. We can also use the API to determine exactly why a particular form field failed to validate.

### Forcing element validation

All form elements and input elements (including `<select`> and `<textarea>`) include a `checkValidity` method on the DOM node. You'd be forgiven for thinking this is the method you'd want to use to override the browser's default validation and feedback process.

The `checkValidity` method returns true or false depending on the success of the validation checks, but at the same time it's telling the browser to run through its checks, and displaying the error messages if required. If you want to take control of the presentation of validation feedback, then you don't want to use this method.

### Element validity

Individual form fields, along with having the `checkValidity` method, also have a validity DOM attribute that returns a `ValidityState` object. There are a number of state attributes on the validity object, but the simplest and most important is the `valid` attribute. This value can be tested using JavaScript to drive a bespoke validation feedback system.

> It's worth noting that `<fieldset>` elements also have the validity attribute, but they don't do anything. The validity attribute is always true. You can also call the `checkValidity` method on fieldsets, but again, nothing happens in the current browsers that support custom validation.

If we hook into the submit event handler on our form, we can manually loop through all the input fields and check the validity object. But what happens if the field has no validation rules? You're in luck: The API provides a `willValidate` attribute that we can test to see whether we should or shouldn't try to validate this particular field. Here's a (contrived) example:

```js
var email = document.getElementById('email');

if (email.willValidate) {
  if (!email.validity.valid) {
    alert("Yarr, ye old email be invalid");
  }
}
```

Once you have the individual form field's validation state, you could pull in any custom messages set via element. `validationMessage` or test the different validity states, which also include `valueMissing`, `typeMismatch`, `patternMismatch`, `tooLong`, `rangeUnderflow`, `rangeOverflow`, `stepMismatch`, and `customError`.

What's particularly important is that you disable the native browser's validation behaviour. By adding the novalidate attribute to the form element, as you'll see next, it disables the validation feedback, but in fact the JavaScript API is still available and you are still able to check the validity state on the fields. This means you can have full control of the error feedback process.

## Avoiding validation

The last question we need to answer is: What if you want to submit the form--but you don't want the browser to validate it? This is possible, too. But why on earth would you want to do this? What if you have a multistage registration form, either for sign-up or for submitting some content? For long forms it could be useful to split the form into stages (as eBay might do when you're selling an item). You might even want to allow your visitors to save the state of their submission, even if the form isn't currently complete and valid.

There are two levels of control for not validating. This can apply to the individual input control or to the entire form. The novalidate attribute can only be set on a form element and prevents validation for that particular field. As we saw in the previous section, if you want to disable the native validation feedback (that is, the little bubbles that appear under the input elements) but still have the JavaScript API available--which still returns true or false for the valid states on the fields--then this bad boy is for you.

The second method, formnovalidate, which is practical and available today, is allowed on individual input elements and button elements (though probably only makes sense on `type="submit"` and `type="button"`). The `formnovalidate` attribute allows the form to be submitted and bypass all the validation that has been set on the form fields. The following example snippet of code would allow you to have a save session button with each fieldset to allow the user to save his progress without triggering the validation rules from running until he hits the final submit button:

```html
<form>
  <fieldset>
    <legend>Some bits about you</legend>
    <div>
      <label for="email">Email:</label>
      <input id="email" name="email" type="email" required />
    </div>
    <div>
      <label for="url">Homepage:</label>
      <input id="url" type="url" name="url" />
  </div>
  <input type="submit" value="save session" formnovalidate />
</fieldset>
```

You could even hook into the save session button to trigger JavaScript-based validation based on only those fields inside the fieldset via the `HTMLFieldSetElement.elements` property (though this is a new property in the HTML5 spec, so you may have to rely on `fieldset.getElementsByTagName` and find all the form fields).

### The "whenever anything changes" event

> In the first edition of this book, we talked about `onforminput`, but since then the event handler has been deprecated. But fear not, this section remains valid, because the very similar `oninput` event handler is part of HTML5 and we can use it in a very similar way to `onforminput`.

One almost insignificant change to the `<form>` element is a new event called oninput. In fact, this is a useful event that fires on the form element when any of the form fields within the form change. This saves you having to attach lots of onchange handlers to each form control.

For instance, if I were to create a colour picker that gives me both RGBA and HSLA, typically I would have to hook event listeners to each of the value sliders. By using the oninputchange event, I'm able to hook a single event listener to the form and recalculate my RGBA and HSLA values using a single method.

Whether I'm attaching lots of event listeners or just a single one, the result is very similar. However, this feels a lot cleaner and better designed, as there's no duplication of event listeners.

When a slider is changed, it generates the RGBA and HSLA and update the preview colour. The code listing below is just the JavaScript required:

```js
form.oninput = function () {
  var i = this.length,
      values = [],
      value = 0;

  while (i--, value = this[i].value) {
    if (this[i].type == 'range') {
      switch (this[i].name) {
        // alpha_channel is between 0-1
        case 'alpha_channel': values.push(value / 100); break;

        // hue is a plain value from 0-360
        case 'hue': values.push(value); break;

        // default includes saturation & luminance as a percentage
        default: values.push(value + '%');
      }
    }
  }

  hsla.value = 'hsla(' + values.reverse().join(', ') + ')';
  preview.style.backgroundColor = hsla.value;

  rgba.value = getComputedStyle(preview, null).backgroundColor;
};
```

My final colour picker makes use of the range input type, the new oninput event, and the new output elements to show the value (though this could easily use `.innerHTML`). The final result is shown in Figure 3.14.

{{figure 3.14
Figure 3.14 An HSLA colour picker using the oninput event.
}}

What's particularly important about the oninput event is that unlike the onchange, which fires only when the element is blurred (although historically some browsers got this wrong, and fired during input--strangely this wasn't IE getting it wrong for a change!), `oninput` fires when the user is inputting to the form and whilst the changes are happening immediately.

## Summary

Hopefully you've seen that HTML5 forms offer a huge productivity boost for developers and a consistent experience for users. They offer a ton of features right out of the box that previously would have required a lot of custom coding (such as form validation, or creating slider controls). Implementation is at varying, but increasing, levels in Opera, the WebKit browsers (Safari and Chrome), and beginning in Firefox and IE10. The lack of implementation in IE9 can be faked with JavaScript, as the new features are designed to degrade gracefully.

Now, let's move on to even sexier subjects.