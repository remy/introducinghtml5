# Text

Now that you've marked up the main page landmarks with HTML5 and seen how a document's outline can be structured, this lesson looks deeper to show how you can further structure your main content.

To do this, you'll mark up a typical blog with HTML5. We've chosen a blog because over 70 percent of web professionals have a [blog](http://www.aneventapart.com/alasurvey2008), and everyone has seen one. It's also a good archetype of modern websites with headers, footers, sidebars, multiple navigation areas, and a form, whether it's a blog, a news site, or a brochure site (with products instead of news pieces). We'll then move on to a case study with a real website to see where you would use the new structures, followed by a look at new elements and global attributes.

## Structuring main content areas

Take a look at the main content area of a blog (Figure 2.1). There may be multiple articles, each containing metadata and the actual textual content of that article.

{{figure 2.1
Figure 2.1 A series of articles on a typical blog.
}}

Here's some typical markup (simplified from the default WordPress theme):

```html
<div class="post">
  <h2>Memoirs of a Parisian lion-tamer</h2>
  <small>January 24th, 2010</small>
  <div class="entry">
    <p>Claude Bottom's poignant autobiography is this ¬summer's must-read.</p>
  </div>
  <p class="postmetadata">Posted in
    <a href="/?cat=3">Books category</a> |
    <a href="/?p=34#respond">No Comments</a>
  </p>
</div>
```

There is nothing majorly wrong with this markup (although we would query use in HTML 4 of the presentational `<small>` element for the date). It will work fine in all browsers, but apart from the heading for the blog post, there is no real structure--just meaningless `<div>`s and paragraphs.

HTML 4 gives us generic structures to mark up content. `<div>`, for example, is just a generic box that tells the browser, "Here's some stuff, it all belongs together," but it doesn't mean anything; there's no semantic value beyond "these belong together." Where possible, we'll replace generic boxes with new HTML5 elements, while still using `<div>` where there isn't an appropriate element, just as we did in HTML 4.

Let's concentrate on an individual article first. As you saw in Chapter 1, you can replace the outer `<div class="post">` with `<article>`, but you can go further still. The HTML5 `<header>` and `<footer>` elements can be used multiple times on a page, each time referring to the section it's in.

> All quotes describing the elements, unless otherwise noted, are from the HTML5 specification as it read at the time of writing.

The heading and the time of posting are introductory matter and thus the job for `<header>`, right? Similarly, the metadata about the post that is currently in a paragraph with class="postmetadata" is better marked up in HTML5 as a `<footer>`, which the spec says "typically contains information about its section, such as who wrote it, links to related documents, copyright data, and the like."

Diagrammatically, the revised structure is shown in Figure 2.2.

{{figure 2.2
Figure 2.2 A single blog article using new HTML5 structures.
}}

```html
<article>
  <header>
    <h2>Memoirs of a Parisian lion-tamer</h2>
    <time datetime=2010-01-24>January 24th, 2010</time>
  </header>
  <p>Claude Bottom's poignant autobiography is this summer's must-read.</p>
  <footer>
    Posted in <a href="/?cat=3" >Books category</a>.
    <a href="/?p=34#respond">No Comments</a>
  </footer>
</article>
```

Let's look at this in more detail.

### The &lt;time&gt; element

The new element `<time>` is used for unambiguously encoding dates and times for machines, while still displaying them in a human-readable way. The uses of this in web pages aren't hard to imagine: a browser could offer to add future events to a user's calendar; content aggregators could produce visual timelines of events; a Thai-localised browser could offer to transform dates into Thai Buddhist era dates, which are numerically 543 years greater than their corresponding Western-style years.

The spec says, "The time element represents either a time on a 24-hour clock, or a precise date in the proleptic Gregorian calendar, optionally with a time and a time-zone offset."

The machine-readable part of the `<time>` element is usually encapsulated in the element's datetime attribute. The content inside the element is what gets presented to end users.

```html
<time datetime=2009-11-13>13 November 2009</time>
<time datetime=2009-11-13>13<sup>th</sup> November last year</time>
<time datetime=2010-11-13>Bruce's 21st birthday</time>
<time datetime=2010-11-13T020:00Z>8PM on my birthday</time>
<time datetime=20:00>8 PM</time>
```

If you're happy to have the machine-readable format visible to the end user as well, you don't need to use a separate datetime attribute. User agents should then simply pick the content of the element and interpret it:

```html
<time>20:00</time>
```

{{aside

# Machine-readable dates and times

To be machine-readable, dates must be in the format YYYY-MM-DD and may also include a time, prefixed with "T" to separate the date and time, in the format HH:MM. Optionally you can append seconds (separated from the minutes with a colon). Fractions of a second are allowed after a full stop mark.

As you've seen above, you can give a time on the 24-hour clock with no date information.

If you're giving time and date together, you need to show the time zone: that's either "Z" for Coordinated Universal Time (UTC), or an offset from UTC in hours and minutes, prefixed with a plus or minus.

Putting that all together: "1979-10-14T12:00:00.001-04:00" represents one millisecond after noon on October 14, 1979, in Eastern Standard Time during daylight saving time (UTC-4 hours).

}}


Reddit.com combines a relative time ("8 hours ago") as the text content of the element, with a title attribute showing the humanreadable full time on hover:

```html
<p>Submitted
  <time
    title="Sun Jul 3 02:15:49 2011 GMT"
    datetime="2011-07-03T02:15:49.881631+00:00">8 hours
  </time> ago
</p>
```

The only trouble with `<time>` is that it must contain a positive date on the proleptic Gregorian calendar--meaning you can't encode a date before the Christian era. Neither can you encode imprecise dates such as "July 1904." This seriously limits its use for sites such as museums, history/encyclopedia pages, or family trees, where precise dates may not be known.

A consortium of search engines, Bing, Google, and Yahoo!, has launched an initiative called schema.org to create and support a series of common markup patterns. This growing set of schemas use HTML5 Microdata (see later in this chapter):

"...in ways recognized by major search providers. Search engines including Bing, Google and Yahoo! rely on this markup to improve the display of search results, making it easier for people to find the right web pages ([www.schema.org](http://www.schema.org))."

> As this second edition goes to press, the Working Group is discussing removing `<time>` from HTML and, to replace it, magicking up a more generic--and therefore less useful--`<data>` element. We hope that this won't happen but before you use it, please see [introducinghtml5.com](http://www.introducinghtml5.com) to find any errata to this book. Or look at the spec!

Note that schema.org uses the `<time>` element to express dates, but uses the full ISO 8601 date format rather than HTML5's cutdown date format, so "2011-09" is a legitimate date, expressing an unspecified day in September 2011. Similarly, durations can be specified via a "P" prefix (for period):

```
<time itemprop="cookTime" datetime="PT1H30M">1.5 hours</time>
```

As we've seen, neither of these schema.org examples have datetime attributes that will validate as HTML5. This puts responsible developers in a quandary--should you aim for the personal karma of valid code, or the tangible business benefits of helping search engines understand your content?

It's silly to force developers to choose, so hopefully the Working Group will see sense and loosen the restrictions on the `<time>` element.

#### The pubdate attribute

The Boolean attribute pubdate indicates that this particular `<time>` is the publication date of an `<article>` or the whole `<body>` content.

You might be wondering why the pubdate attribute is needed at all. Why not just assume that any `<time>` element in an `<article>`'s `<header>` is its publication date?

Consider this example:

```html
<article>
  <header>
    <h1>Come to my party on
      <time datetime=2010-12-01>1 December</time>
    </h1>
    <p>Published on
      <time datetime=2010-06-20 pubdate>20 June 2010</time>
    </p>
  </header>

  <p>I'm throwing a party at Dr Einstein's Cabaret Roller-disco Bierkeller Pizza-parlour-a-gogo. Do come and dance to Rusty Trombone's Swingin' Brass Band. (Formal dress and lewd hat required.)</p>
</article>
```

You'll see that there are two dates within the `<header>`: the date of the actual party and the publication date of the article. The pubdate attribute is required to remove any ambiguity. And yes, you are invited--just don't get drunk this time.

### More fun with headers and footers

The main surprise with our article makeover is that each article can have its own `<header>` and `<footer>`. This means that,

in addition to the "main" header and footer on a page, each article can have its own headers and footers as well. They can be separately styled with CSS: for instance, `body>header` and `body>footer` target the main headers and footers (assuming that they're direct descendants of `<body>`), whereas article>header and article>footer target the inner structures.

To include old versions of Internet Explorer, you can take advantage of specificity. Define generic header and footer styles, and then redefine/override them for article header and article footer:

```css
/*page header */
header {
  display:block;
  color:red;
  text-align:right;
}

/*article header */
article header {
  color:blue;
  text-align:center;
}
```

Note that so far you've introduced no ids or classes as hooks for CSS.

#### Using multiple &lt;footer&gt;s on the same element

The spec says, "Footers don't necessarily have to appear at the end of a section, though they usually do," and it allows an element to have two or more footers. A simplified version of the example in the spec is

```html
<body>
  <footer>
    <a href="/">Back to index...</a>
  </footer>
  <h1>Lorem ipsum</h1>
  <p>Lorem ipsum</p>
  <footer>
    <a href="/">Back to index...</a>
  </footer>
</body>
```

The reason for this is that the elements are supposed to be nonpresentational. If "back to index" is the footer below the article, and you choose to have another "back to index" above the article, too, you should use the same element for the same content, regardless of where it appears.

#### Using &lt;blockquote&gt; &lt;footer&gt;s

Very groovily, `<blockquote>` can have a footer, which is a very useful way of citing the source in a way that's unambiguously associated with the quotation but also nicely presented to your users. HTML4 has the `cite` attribute on `<blockquote>` which in theory serves this purpose by allowing authors to provide a link to the original source, but no browsers do anything with it so the source isn't displayed anywhere to the user:

```html
<blockquote>
Thou look'st like antichrist, in that lewd hat. <footer>Ananias <cite>Scene 4.3, <a href="http://www.gutenberg.org/files/4081/4081-h/4081-h.htm">The Alchemist</a></cite> (Ben Jonson)</footer>
</blockquote>
```

Since the first edition of this book, it's been suggested that using `<footer>` inside `<blockquote>` for attributing the source of the quotation is wrong, because according to the spec, "Content inside a blockquote must be quoted from another source," and attribution isn't a quote. However, this seems incorrect; often you "tidy" quotes by adding ellipses, silently correcting spelling and such, which isn't strictly quoting. Also, many web publications include the attribution inside the quotation, which isn't allowed by the spec at the moment (see fellow HTML5 Doctor Oli Studholme's research at [oli.jp/2011/blockquote]( http://oli.jp/2011/blockquote/)). Therefore, we consider that disallowing the use above is a spec bug.

## Adding blog posts and comments

So, you have a page with a header, footer, navigation, and content areas containing several articles (blog posts), each with its own header and footer. But wait...what is a blog without comments?

The specification mentions this case, and recommends the use of nested `<article>`s: "When article elements are nested, the inner article elements represent articles that are in principle related to the contents of the outer article. For instance, a blog entry on a site that accepts user-submitted comments could represent the comments as article elements nested within the article element for the blog entry."

So let's do that. Note as well that blog comments are typically shown in chronological order and have information such as author's name and URL--in short, header information. Diagrammatically it looks like Figure 2.3.

{{figure 2.3
Figure 2.3 The structure of a blog post, with comments as nested articles.
}}

The code is as you'd expect, with comments highlighted:

```html
<article>
  <header>
    <h1>Come to my party on <time datetime=2010-12-01>1 December</time></h1>
    <p>Published on <time datetime=2010-06-20 pubdate>20 June 2010</time></p>
  </header>
  <p>I'm throwing a party at Dr Einstein's Cabaret Roller-disco Bierkeller Pizza-parlour-a-gogo. Do come and dance to Rusty Trombone's Swingin' Brass Band. (Formal dress and lewd hat required.)</p>
  <footer>Published in the Parrtay!! category by Bruce</footer>

  <article><!-comment -->
    <header>
      Comment from <a href="http://remysharp.com">Remy Sharp</a> at <time datetime="2010-05-01T08:45Z"> 8.45 on 1 May 2010</time>
    </header>
    <p>I'll be there. I very much enjoy a bit of Rusty Trombone.</p>
  </article><!-end comment -->
  <article> <!-comment -->
    <header>
      Comment from <a href="http://splintered.co.uk">Patrick Lauke</a> at <time datetime="2010-05-02T10:45Z">10.45 on 2 May 2010</time>
    </header>

    <p>Sorry mate. Am off to Bath to see TubaGirl.</p>
  </article> <!-end comment -->
</article> <!-end blogpost -->
```

## Working with HTML5 outlines

Some word processing applications have a function to show you the outline of a document. For example, Figure 2.4 shows this chapter in Microsoft Word 2007's outline view.

{{figure 2.4
Figure 2.4 Microsoft Word 2007's outline view.
}}

HTML5 has a tightly defined outlining algorithm that allows user agents to produce a similar outline from a web page. Just as with a word-processing package, this could be used to give the user a quick overview of the web page (and, of course, there's no reason why the web page shouldn't actually be a wordprocessing application). The other main use for the outlining algorithm is for syndication: grabbing content and inserting it somewhere else and ensuring that the destination web page still has a logical structure.

A word of warning: This section of the chapter is pretty dense, and it hasn't been implemented by any browsers yet (although there is a [JavaScript implementation](http://code.google.com/p/h5o/), which has been wrapped as a Chrome extension from the same URL, and as an [Opera extension](https://addons.opera.com/addons/extensions/details/html5-outliner/). You need to understand the concept of the document outline to know when to use `<section>`, `<aside>`, or `<div>`.

One major departure from HTML 4, and an important concept to grasp before you proceed, is that certain HTML5 elements-- `<article>`, `<section>`, `<nav>`, and `<aside>`--are sectioning content, which begin new sections in the outline. To explain this concept, let's take this simple code:

```html
<h1>Hello</h1>
<div>
 <h1>World</h1>
</div>
```

{{figure 2.5
Figure 2.5 A simple outline. 1. Hello
}}

{{figure 2.6
Figure 2.6 A document outline after `<div>` is replaced by `<article>`.
}}

To illustrate how this algorithm works, I'm using a [web-based outline utility](http://gsnedders.html5.org/outliner/), as no browser currently has this logic embedded. The outline this code generates is as you would expect (Figure 2.5).

{{figure 2.6
Figure 2.6 shows what happens if you change the meaningless `<div>` to an `<article>`, which is sectioning content:
}}

```html
<h1>Hello</h1>
<article>
 <h1>World</h1>
</article>
```

The presence of sectioning content has shifted its content to be hierarchically "below" the content that preceded it. Or, to put it more simply: the `<h1>` inside the article is a logical `<h2>` because

`<article>` has started a new section. Using `<section>`, `<nav>`, or `<aside>` instead of `<article>` does the same thing, as they are all sectioning content.

In fact, it doesn't matter what level of heading you use here; the outlining algorithm cares about nesting and relative levels, so this code

```html
<h3>Hello</h3>
<article>
 <h6>World</h6>
</article>
```

produces exactly the same result as Figure 2.6.

You might be saying, "So what. What's the use for that?" Well, firstly, it means you're not restricted to six levels of headings, as you are in HTML 4. A heading element nested inside seven levels of `<section>`, `<article>`, `<nav>`, or `<aside>` (or any combination of them) becomes a logical `<h7>` element (however, unless you're marking up legal documents or some other horrors, you should reconsider your content if you need so many levels).

Another advantage is with syndication. Suppose Remy posts an article:

```html
<article>
<h1>What I did on my holiday</h1>
<p>I went to Narnia. I was bitten by a trilobite. Then I came home.</p>
</article>
```

{{aside

# From TBL '91 to XHTML 2 to HTML5

All very newfangled, isn't it? Well, no; the idea that logical headings should depend on their nesting in `<section>`s was first floated in 1991 by Sir Tim Berners-Lee himself:

"I would in fact prefer, instead of &lt;H1&gt;, &lt;H2&gt; etc for headings...

to have a nestable &lt;SECTION&gt;..&lt;/SECTION&gt; element, and a generic &lt;H&gt;..&lt;/H&gt; which at any level within the sections would produce the required level of heading."

For some reason this didn't make it into HTML. It was revived for XHTML2 and re-revived by HTML5, but without an `<h>` element-- for backwards-compatibility reasons, `<h1>` to `<h6>` are used instead.

}}

Let's say you run a large online newspaper and naturally wish to syndicate this story. When the magic syndication machines slot it into your template, the resulting code is

```
<h1>The Monotonous Times</h1>
<section>
  <h2>Breaking news</h2>
  <article>
    <h1>What I did on my holiday</h1>
    <p>I went to Narnia. I was bitten by a trilobite. Then I came home.</p>
  </article>
...
</section>
```

It's obvious that "breaking news" is higher in the hierarchy of headings than the title of Remy's blog post, but due to a mismatch between Remy's template and your template, there's an `<h2>` that is more important than the `<h1>`.

Checking the outline, however, shows us that everything is as it should be (Figure 2.7). You clever thing, you.

{{figure 2.7
Figure 2.7 The outlining algorithm produces the correct outline in syndication, too.
}}

### &lt;nav&gt;, &lt;aside&gt;, and untitled sections

A quick word about the outlining tools, as you'll probably get into the habit of checking your document outlines as part of your development process, much as you regularly validate your code and check it in different browsers.

Generally, if a tool finds sectioning content that has no heading, it will report it. So this snippet

```html
<article>
  <p>I have no heading</p>
</article>
```

gives the outline "Untitled Section." For `<section>`s and `<article>`s, this is a useful warning, as these elements nearly always begin with a heading.

However, inside `<nav>` and `<aside>` it's perfectly legitimate not to have a heading. You may want to do it for some `<nav>` blocks, such as "Most popular posts" or "Recent comments," but you probably don't want a heading on your main site `<nav>` that just says "Navigation."

Therefore, if you see "Untitled Section," don't automatically assume that you should put a heading there. Treat it as a warning, not an error.

### &lt;hgroup&gt;

Sometimes you have a heading and a subheading, or tagline. Slashdot uses "News for nerds, stuff that matters"; dev.opera has "Follow the Standards. Break the Rules"; Metafilter is a "community weblog." How do you mark up those taglines? In HTML 4, you could use

```html
<h1>Metafilter</h1>
<h2>community weblog</h2>
```

> We haven't used a`<header>` element in this `<article>`. `<header>` is a grouping element that collects together introductory content; as you only have headings already grouped in `<hgroup>`, there's no need for a further layer of grouping. It wouldn't be an error to use it, but it's superfluous in this example.

but that doesn't feel right, as the subtitle feels like it should be a heading. An alternate method of marking this up could be

```html
<hgroup>
  <h1>Metafilter</h1>
  <h2>community weblog</h2>
</hgroup>
```

but then every header on the site would need to be `<h3>` to `<h6>` as they're subordinate to the tagline. In HTML5, the subtitle can be marked up as a heading element but removed from the document outline, like so:

This gives the outline shown in Figure 2.8.

{{figure 2.8
Figure 2.8 The outline shows only "Metafilter" as part of the outline.
}}

The spec for `<hgroup>` says, "For the purposes of document summaries, outlines, and the like, the text of hgroup elements is defined to be the text of the highest-ranked h1–h6 element descendant of the hgroup element."

So:


```html
<hgroup>
  <h2>Get the beers in! Here comes</h2>
  <h1>Remy Sharp!</h1>
</hgroup>
```

shows the text "Remy Sharp" in the outline, as that's the highestranking heading element in the group.

### Sectioning roots

Note that certain elements--`<blockquote>`, `<body>`, `<details>`, `<fieldset>`, `<figure>`, `<td>`--are said to be sectioning roots, and can have their own outlines, but the sections and headings inside these elements do not contribute to the outlines of their ancestors. This is because, for example, you could quote several sections of an article in a `<blockquote>`, but those quoted sections don't form part of the overall document outline.

In the following example:

```html
<h1>Unicorns and butterflies</h1>
<nav>
  <h2>Main nav</h2>
  ...
</nav>
<article>
  <h2>Fairies love rainbows!</h2>
  <p>According to Mr Snuggles the fluffy kitten, fairies
like:</p>
  <blockquote>
    <h3>Pretty dainty things</h3>
    <p>Fairies love rainbows, ribbons, and ballet shoes</p> <h3>Weaponry</h3>
    <p>Fairies favour Kalashnikovs, flick knives, and ¬depleted uranium missiles</p>
 </blockquote>
</article>
```

the outline does not include the contents of blockquote: (Figure 2.9).

{{figure 2.9
Figure 2.9 The outline does not include content in a sectioning root.
}}

### Styling headings in HTML5

All this clever stuff presents a challenge to authors of CSS. Given that

```html
<article><section><h1>...</h1></section></article>
<article><article><h1>...</h1></article></article>
<section><section><h1>...</h1></section></section>
<section><aside><h1>...</h1></aside></section>
<h3>...</h3>
```

can potentially be the same logical levels, you might wish to apply the same styling to them. This can lead to gigantic blocks of rules in your style sheets. There has been some talk of a new CSS pseudo-class or pseudo-element like `:heading(n)` (as internally the browser will "know" what level a heading is from the outlining algorithm) which would simplify styling:

```css
*:heading(1) {font-size: 2.5em;} /* a logical <h1> */
*:heading(2) {font-size: 2em;} /* a logical <h2> */
```

However, at the time of this writing, this is but a wonderful dream. As a stopgap, Mozilla is experimenting with a new selector grouping mechanism in Firefox nightlies called `:-moz-any()` that allows a form of CSS shorthand--go to [hacks.mozilla.org](http://hacks.mozilla.org/2010/05/moz-any-selector-grouping/) to learn more.

Perhaps, for this reason, you would be tempted to use only `<h1>` elements to simplify styling, and let the outlining algorithm do the rest. After all, the spec says, "Sections may contain headings of any rank, but authors are strongly encouraged to either use only h1 elements, or to use elements of the appropriate rank for the section's nesting level." But you shouldn't (yet) as it harms accessibility.

### The outlining algorithm and accessibility

> Watch the excellent video entitled ["Importance of HTML Headings for Accessibility"](www.youtube.com/ watch?v=AmUPhEVWu_E). The video shows how a blind accessibility consultant navigates a page with JAWS. In an ideal world, it would be compulsory to watch and understand this video before you're allowed to call yourself a professional designer or developer. Sadly, it's not an ideal world.

A recent survey by WebAIM showed that 57 percent of screen reader users use a site's headings structure as their first method to find information on a lengthy site. (See the full survey for more vital information at [www.webaim.org/projects/screenreadersurvey3](http://www.webaim.org/projects/screenreadersurvey3)). These people use the hierarchy of headings both to give themselves a mental overview (an outline!) of the document they're in and also to navigate through that content. Most screen readers have keyboard shortcuts that allow users to jump from heading to heading. For example, the JAWS screen reader (by far the most used package, according to the survey) uses the H key to jump from heading to heading, the 1 key to jump to the next `<h1>`, the 2 key to go to the next `<h2>`, and so on.

Currently, no browser builds an internal model of the page structure based on all the complex rules previously mentioned and therefore can't expose this model to any screen reader or assistive technology. So, using only `<h1>` wrecks the navigability and therefore hinders the accessibility of your page.

Our advice is again, follow the spec: "Use elements of the appropriate rank for the section's nesting level." That is, ensure that, in your pages, the hierarchy of headings is correct even without factoring in new HTML5 elements. It will also make writing CSS much easier.

In cases when articles are syndicated from one site to the other and the levels might be out of logical order, a completely unscientific Twitter poll of screen reader users suggested that badly nested section headers are better than all headings being at the same level (which is still better than no headings at all).

And, having done your best, wait for the browsers and the screen readers that sit on top of them to implement the outlining algorithm. As I said, it's not an ideal world.

### What's the difference between &lt;article&gt; and &lt;section&gt;?

This is a question that is regularly asked of us at html5doctor.com.

An article is an independent, stand-alone piece of discrete content. Think of a blog post, or a news item in a document-based site. In a web application, an `<article>` could be individual emails within an email application or stories in a web-based feed reader, as each email or story is a component of the application and can be independently reused. Think of `<article>` not as a newspaper or magazine article, but as a discrete entity like an article of clothing.

#### &lt;article&gt;

Consider this real-world blog/news article:

```html
<article>
  <h1>Bruce Lawson Is World's Sexiest Man</h1>
  <p>Legions of lovely ladies voted luscious lothario Lawson as the World's Sexiest Man today.</p>
  <h2>Second-sexiest man concedes defeat</h2>
  <p>Remington Sharp, JavaScript glamourpuss and Brighton roister-doister, was gracious in defeat. "It's cool being the second sexiest man when number one is Awesome Lawson" he said from his swimming pool-sized jacuzzi full of supermodels.</p>
</article>
```

It could be syndicated, either by RSS or other means, and makes sense without further contextualisation. Just as you can syndicate partial feeds, a "teaser" article is still an article:

```html
<article>
  <a href=full-story.html>
    <h1>Bruce Lawson is World's Sexiest Man</h1>
    <p><img src=bruce.png alt="bruce lawson">Legions of lovely ladies voted luscious lothario Lawson as the World's Sexiest Man today.</p>
    <p>Read more</p>
  </a>
</article>
```

{{aside

# "Block-level" links

Note from this example that you can wrap links around "block-level" elements. In the HTML 4 spec, this is not allowed, so you would probably have links around the heading, the teaser paragraph, and the phrase "read more" all pointing to the same destination.

However, it turns out that all browsers quite happily (and consistently) allowed links to be placed around various block-level elements (with a bit of coaxing--see [Matt's block anchor test](http://www.mattwilcox.net/sandbox/html5-block-anchor/test.html), and it was only the old HTML spec that didn't allow it, so in HTML5 one link can surround the whole `<article>`. As the browsers already handle wrapping links around block-level elements, and there is an obvious use-case, there was no reason to artificially keep the structure as invalid.

It's always been a good idea (for accessibility and usability alike) to "front-load" important information at the start of links. Now, with the possibility of having even larger chunks of content wrapped up as a link, this is even more important ([hat tip, Steve Faulkner](http://www.paciellogroup.com/blog/2011/06/html5-accessibility-chops-block-links)).

}}

As you've seen, comments on blog posts are `<article>`s inside a parent `<article>`. There are other uses for this nesting besides comments--for example, a transcript to a video:

```html
<article>
  <h1>Stars celebrate Bruce Lawson</h1>
  <video>...</video>
  <article class=transcript>
    <h1>Transcript</h1>
    <p>Supermodel #1: "He's so hunky!"</p>
    <p>Supermodel #2: "He's a snogtabulous bundle of gorgeous ¬manhood! And I saw him first, so hands off!"</p>
  </article>
</article>
```

The transcript is complete in itself, even though it's related to the video in the outer `<article>`. Remember: The spec says, "When article elements are nested, the inner article elements represent articles that are in principle related to the contents of the outer article."

#### &lt;section&gt;

> A `<section>` generally begins with a heading that introduces it. An exception to this might be a `<section>` that will have a heading injected using JavaScript. If you wouldn't use a heading, or you want some wrapping element purely for styling purposes you probably should be using a `<div>`.

Compared to `<article>`, `<section>` is not "a self-contained composition in a document, page, application, or site and that is intended to be independently distributable or reusable." It's either a way of sectioning a page into different subject areas, or sectioning an article into, well, sections.

Consider this HTML 4 markup--the rules from Remy's previous job in an off-Broadway production of The Wizard of Oz:

```html
<h1>Rules for Munchkins</h1>
<h2>Yellow Brick Road</h2>
<p>It is vital that Dorothy follows it--so no selling bricks as "souvenirs"</p>
<h2>Fan Club uniforms</h2>
<p>All Munchkins are obliged to wear their "I'm a friend of Dorothy!" t-shirt when representing the club</p>
<p><strong>Vital caveat about the information above: does not apply on the first Thursday of the month.</strong></p>
```

Does the "Vital caveat about the information above" refer to the whole article, that is, everything under the introductory `<h1>`, or does it refer only to the information under the preceding `<h2>` ("Fan Club uniforms")? In HTML 4, that paragraph would fall under the `<h2>`, and there's no easy way to semantically change this. In HTML5, the `<section>` element makes its meaning unambiguous (which is what we really mean as web developers when we use the word "semantic"):

```html
<article>
  <h1>Rules for Munchkins</h1>
  <section>
    <h2>Yellow Brick Road</h2>
    <p>It is vital that Dorothy follows it--so no selling ¬bricks as "souvenirs"</p>
  </section>
  <section>
    <h2>Fan Club uniforms</h2>
    <p>All Munchkins are obliged to wear their "I'm a friend ¬of Dorothy!" t-shirt when representing the club</p>
  </section>
  <p><strong>Vital caveat about the information above: ¬does not apply on the first Thursday of the month.</strong></p>
</article>
```

Figure 2.10 illustrates this diagrammatically.

{{figure 2.10
Figure 2.10 Now you can see that the vital caveat refers to the whole `<article>`.
}}

If it had been inside the final section element

```html
<article>
...
  <section>
    <h2>Fan Club uniforms</h2>
    <p>All Munchkins are obliged to wear their "I'm a friend of Dorothy!" t-shirt when representing the club</p>
    <p><strong>Vital caveat about the information above: does not apply on the first Thursday of the month</strong></p>
  </section>
</article>
```

it would unambiguously refer to that section alone, as illustrated in Figure 2.11.

{{figure 2.11
Figure 2.11 The `<section>` element removes any ambiguity.
}}

It would not have been correct to divide up this article with nested article elements, as they are not independent discrete entities.

OK. So you've seen that you can have `<article>` inside `<article>` and `<section>` inside `<article>`. But you can also have `<article>` inside `<section>`. What's that all about then?

#### &lt;article&gt; inside &lt;section&gt;

Imagine that your content area is divided into two units: one for articles about llamas, the other for articles about root vegetables. That's my kind of content.

You're not obliged to mark up your llama articles separately from your root vegetable articles, but you want to demonstrate that the two groups are thematically distinct. Perhaps, because they're thematically distinct, you want them in separate columns, or you'll use CSS and JavaScript to make a tabbed interface.

In HTML 4, you'd use our good but meaningless friend `<div>`. In HTML5, you use `<section>`, which, like `<article>`, invokes the HTML5 outlining algorithm (whereas `<div>` doesn't, because it has no special structural meaning).

```html
<section>
  <h1>Articles about llamas</h1>
  <article>
    <h2>The daily llama: Buddhism and South American camelids</h2>
    <p>blah blah</p>
  </article>
  <article>
    <h2>Shh! Do not alarm a llama</h2>
    <p>blah blah</p>
  </article>
</section>

<section>
  <h1>Articles about root vegetables</h1>
  <article>
    <h2>Carrots: the orange miracle</h2>
    <p>blah blah</p>
  </article>

  <article>
    <h2>Eat more Swedes (the vegetables, not the people)</h2>
    <p>blah blah</p>
  </article>
</section>
```

Why didn't you mark the two `<section>`s up as `<article>`s instead? Because, in this example, each `<section>` is a collection of independent entities, each of which could be syndicated--but you wouldn't ordinarily syndicate the collection as an individual entity.

Note that a `<section>` doesn't need to contain lots of `<article>`s; it could be a collection of paragraphs explaining your creative commons licensing, an author bio, or a copyright notice. In our example, each article could contain sub-articles or sections, as explained earlier--or both.

> All of your which-structural-element-should-I choose conundrums are easily solved with [The Amazing HTML5 Doctor Easily Confused HTML5 Element Flowchart of Enlightenment!](http://www.html5doctor.com/flowchart).

Estelle Weyl has a [good analogy](http://www.standardista.com/html5-section-v-article): "Think of a newspaper. The paper comes in sections. You have the sports section, real estate section, maybe home & garden section, etc. Each of those sections, in turn, has articles in it. And, some of those articles are divided into sections themselves.

In other words, you can have parent `<section>`s with nested `<article>`s that in turn have one or many `<section>`s. Not all pages' documents need these, but it is perfectly acceptable and correct to nest this way."

### Case study: www.guardian.co.uk

Let's continue with the newspaper theme and look at a real site and work out where you would use the new structures. Figure 2.12 shows a screenshot from my favourite newspaper, the [Guardian](http://www.guardian.co.uk). Let's see how this could be represented in HTML5.

{{figure 2.12
Figure 2.12 The Guardian homepage.
}}

The following is how I would mark up this page; you might choose different structures, and that's OK. There's not necessarily "one true way" of doing this; it depends in part on how you intend to use the content--will you syndicate it, or pull it out of a database for display in several different page templates with a variety of heading hierarchies?

It's pretty easy to see the branding and introductory matter that forms the `<header>`, which also includes two `<nav>` structures for site-wide navigation (Figure 2.13).

{{figure 2.13
Figure 2.13 The Guardian homepage's branding and introductory matter.
}}

I've used two separate `<nav>`s because the top band ("News, Sport, Comment.") is site-wide, whereas the second band ("News, UK, World.") is section-wide. An alternative structural approach would be to have a single `<nav>` in the header, with the section-wide navigation as a sublist of the site-wide navigation:

```html
<nav>
<ul>
  <li><a href=...>News<a>
    <ul>
    <li><a href=...>News</a></li>
    <li><a href=...>UK</a></li>
    <li><a href=...>World</a></li>
    ...
    </ul>
  </li>
  ...
</ul>
</nav>
```

Immediately below the header is an area with the title "breaking news" and a "ticker" of text. Each summary is a link to an expanded story (Figure 2.14).

{{figure 2.14
Figure 2.14 The "breaking news" area of the Guardian homepage.
}}

Aside from the JavaScript-controlled ticker effect, this "breaking news" is simply a list of links to other pages. Therefore, it matches the `<nav>` element. Don't be fooled by the fact that it's horizontal, with the heading on the same line; CSS will sort that out:

```html
<nav>
<h2>Breaking news</h2>
<ul>
  <li><a href=...>Four schoolchildren injured...</a></li>
  <li><a href=...>Terrible thing happens to someone</a></li>
  ...
</ul>
</nav>
```

Although visually this area appears closely tied with the header, it's not introductory matter or site-wide navigation. The difference is subtle, but in my opinion, links to comments, TV, and sports pages are part of site-wide navigation, while navigating news stories on a news site is "shortcut navigation" to deeper content. Therefore, this is a `<nav>` after, rather than inside, the `<header>` element.

There's more navigation on the right of the main content area (Figure 2.15).

As you saw in Chapter 1, sidebars are often composed of navigation plus other non-nav stuff. We're using the `<aside>` element to group it all together.

```html
<aside>
<nav>
  <h2>guardianjobs</h2>
  <form role=search ... >
    ...
  </form>
  <ul>
    <li><a href=...>Upload your CV</a></li>
    ...
  </ul>
  <h2>Online Dating</h2>
  <ul>
  ...
  </ul>
  ...
</nav>

<section>
  <h2>Sponsored Features</h2>
<section>

</aside>
```

{{figure 2.15
Figure 2.15 A sidebar of navigation on the right side of the Guardian homepage.
}}

Our navigation is a single `<nav>` element containing multiple unordered lists--each with its own heading (Jobs, Dating, CD box sets, Today's paper, and so on), styled with a blue-grey background and a thick red border-top.

> I've included a search form inside the `<nav>` (but outside the `<ul>`s); it seems appropriate to me to regard a search form as a navigational aid. I've also given it the ARIA role appropriate to its function.

However, contrary to my advice in the first edition of this book,

I haven't wrapped each list in its own `<nav>` element, because my purpose is to help assistive technology users to find navigation. Lots of individual `<nav>`s next to each other would probably make it harder rather than easier for those users. This is speculation, however, and once assistive technologies support `<nav>`, this would need to be user-tested.

"Sponsored Features" isn't inside `<nav>` as it's not primary navigation; presumably, its main purpose is to advertise. There's nothing to stop us styling its heading the same as the headings inside the `<nav>` though, and that's what the design requires.

Now let's look at the main content area (Figure 2.16).

{{figure 2.16
Figure 2.16 The main content area of the Guardian homepage.
}}

Unsurprisingly for a newspaper site, the main content area

of the Guardian homepage is given over to news articles. It's important to notice that there is no overriding heading grouping the main articles (such as "top stories"); otherwise you could wrap the whole thing up in a `<section>`. Therefore, you just have a list of `<article>`s. Because `<section>` isn't appropriate here, if there is a need to wrap all the articles with an element for styling purposes, you'd use the semantically empty `<div>` element.

There is one featured article that consists mostly of an image, presumably because it's the most striking image available (Figure 2.17).

{{figure 2.17
Figure 2.17 The featured picture.
}}

This remains simply an `<article>`, although you might need a class or id to allow special styling.

Below the featured article, you have some sections that aren't the top stories; there is less information on the homepage, and they're primarily, but not solely, links to other pages. Each has its own heading ("Best of guardian.co.uk," "Latest multimedia," "What you're saying"), and then a group of articles. The natural elements are therefore `<article>`s within `<section>`s:

```html
<section>
  <h2>Best of guardian.co.uk</h2>
  <article>
    <h3>Is Britain broken?</h3>
    ...
  </article>
  <article>
    <h3>Notes and queries</h3>
    ...
  </article>
  <article>
    <h3>Tech Weekly live: Personal privacy</h3>
    ...
  </article>
  ...
</section>

<section>
  <h2>Latest multimedia</h2>
  ...
</section>
```

On the website (but not in the screenshot), there are also a couple more `<nav>` blocks ("Trending," "Campaigns and investigations") and a "fat footer" that, as we saw in Chapter 1, should be a couple of page-wide `<nav>` blocks outside the "real" `<footer>` that contains the usual privacy, terms and conditions, and accessibility information.

And there it is, ladies and gentlemen: an HTML5 version of [www.guardian.co.uk](http://www.guardian.co.uk). Like any other exercise in markup above the level of the trivial, there are legitimate differences of opinion. That's OK. HTML is a general language, so there aren't elements for every specific occasion. Choose the most appropriate element for the job and be consistent when marking up similar content throughout the site.

## Understanding WAI-ARIA

The W3C Web Accessibility Initiative's Accessible Rich Internet Applications suite (WAI-ARIA) is an independent spec that "plugs the holes" in HTML 4 (or any other markup language) to help make web applications and web pages more accessible.

> If you start using these new ARIA attributes, you may notice that your HTML 4 pages won't validate anymore. As long as the rest of your markup is OK, that doesn't matter--accessibility trumps validity. The ARIA attributes won't cause any kind of DOM weirdness or cause any malfunction in browsers--like with CSS rules, they're just ignored if they're not understood.

Imagine that you have scripted a slider control. In HTML 4 there is no native slider, so you just have some HTML elements (an <input>, some images) with some JavaScript attached to act and look like a slider. There is no way to tell the operating system that the role of this widget is a slider and what its current state and value are. If the operating system doesn't know that vital information, assistive technology such as a screen reader can't convey it to the user either.

ARIA aims to bridge this situation by introducing a whole series of new attributes that browsers and assistive technologies can hook into.

So, using horrible old-school HTML you could--in theory--add ARIA to

```html
<font size="+5" color="red">I should be a heading</font>
```

to make

```html
<font size="+5" color="red" role="heading" aria-level="2"> ¬I should be a heading</font>
```

This tells the user agent that this text is a heading, level 2. But of course, this would be nonsense, as HTML already has a perfectly valid and semantic way of defining this sort of structure with

```html
<h2>I AM a heading</h2>
```

A developer might forget to bolt on the necessary ARIA attributes, whereas using the correct `<h2>` element has built-in "heading-ness" and built-in level so it's a lot more robust. ARIA is not a panacea or "get out of jail free" card for developers to start abusing markup and make everything out of `<div>`s and `<span>`s. Whenever possible, use the correct markup and use ARIA only in situations where the correct semantics can't be otherwise expressed (a slider in HTML 4 example, for instance).

The ARIA spec says, "It is expected that, over time, host languages will evolve to provide semantics for objects that previously could only be declared with WAI-ARIA. When native semantics for a given feature become available, it is appropriate for authors to use the native feature and stop using WAI-ARIA for that feature."

So something like HTML5 `<nav>` shouldn't need ARIA role=navigation added to it, because it should (in an ideal world) have that built-in. However, HTML5 is very new, whereas ARIA already has some support in assistive technology. So it shouldn't hurt to use the built-in element plus the ARIA information, and it can only help users who rely on assistive technology. The HTML5 validator therefore validates ARIA as well as HTML5 (whereas HTML 4 validators report ARIA information as an error because HTML 4 predates ARIA).

{{figure 2.18
Figure 2.18 A simple page with a header, sidebar, and main content area and ARIA roles.
}}

ARIA document structure

and landmark roles

WAI-ARIA defines several roles that tell assistive technology about landmarks and the structure of a document. Some of these are:

- application
- article
- banner
- complementary contentinfo
- document form
- heading main
- navigation search
Looking at a simple page from an ARIA perspective, you might see what is shown in Figure 2.18.

Banner

Content

Some of these obviously match HTML5 elements, such as <article>, <form>, <header>, and <nav>.

Others lack an obvious one-to-one correspondence. For example, role=banner "typically includes things such as the logo or identity of the site sponsor, and site-specific search tool. A banner usually appears at the top of the page and typically spans the full width." That initially seems to match HTML5 <header>, but as you've seen, there can be multiple <header>s on a page. So the "page header" is the only one allowed to have role=banner.

Navigation

Similarly, contentinfo is defined as "a large perceivable region that contains information about the parent document. Examples of information included in this region of the page are copyrights and links to privacy statements." This sounds like <footer>, but it's only the "page footer" and not each footer in a page with multiple footers.

role=main defines the "main content area" of a page. We discussed in Chapter 1 how that can be algorithmically deduced, but as assistive technologies can make use of ARIA now, it makes sense to add this role to the element you're using to group your main content. You can even use it as a hook for CSS in browsers that understand attribute selectors:

div[role=main] [{color:red;]({color:red;) background[-color:yellow;](-color:yellow;) ¬font-family: "Comic Sans MS", cursive; ... }

There you have it: accessibility and gorgeous typography in perfect harmony.

Combining ARIA and HTML5

We recommend that you consider using ARIA where appropriate in addition to HTML5 as a transitional measure to improve accessibility that won't harm validation (but see the following note on screen readers). However, we don't do that in this book (as we're teaching you HTML5, not ARIA). A small polyfill at[ http://github.com/yatil/accessifyhtml5.js]( http://github.com/yatil/accessifyhtml5.js) adds roles to the most common, generic HTML5 cases, but note that (sadly) it won't magically accessify heavy-duty __AJAXed__ web apps.

ARIA resources

There is a useful cross-reference in the spec of HTML5 and ARIA at[ http://dev.w3.org/html5/spec/embedded-content-0]( http://dev.w3.org/html5/spec/embedded-content-0). html#annotations-for-assistive-technology-products-aria. Steve Faulkner of The Paciello Group has a list of ARIA information that HTML5 doesn't have built-in at[ www.paciellogroup.com/]( www.paciellogroup.com/) blog/?p=585.

For more information on ARIA in general, see Gez Lemon's "Introduction to WAI-ARIA" at[ http://dev.opera.com/articles/]( http://dev.opera.com/articles/) view/introduction-to-wai-aria/ and follow The Paciello Group's blog (www.paciellogroup.com/blog/). Two recommended books are Universal Design for Web Applications by Wendy Chisholm and Matt May (O'Reilly) and Designing with Progressive

Enhancement: Building the Web that Works for Everyone by Todd Parker, et al. (New Riders) for useful information on practical uses of ARIA.

The ARIA spec itself is at[ www.w3.org/WAI/PF/aria/]( www.w3.org/WAI/PF/aria/).

A note on screen readers

Houston, we have a problem.

In 2007, I was concerned that no screen reader vendors were participating in the HTML5 specification process, so I wrote to the W3C to ask it to invite vendors to join. In 2009, I asked HTML editor Ian Hickson if any vendors had responded. He replied, "A couple did, but only to say they had little time for the standards process, which was quite disappointing. Since then, though, Apple has ramped up their efforts on their built-in Mac OS X screen reader software, and we do get a lot of feedback from Apple. So at least one screen reader vendor is actively involved."

A recent test (http://www.accessibleculture.org/research/html5-aria-2011/) shows that older versions of two widely used commercial screen readers cannot properly process content that is marked up with both HTML5 and ARIA (oh, the irony) or in <nav> elements inside a <header>. Not all screen readers misbehave, however; Apple __VoiceOver__ does not omit content, JAWS 12 fixed bugs in versions 10 and 11, and the open-source NVDA screen reader (www.nvda-project.org/) speaks all content and allows navigation by ARIA landmarks.

Personally, I feel that if you are using the specification the right way, it's not your problem if a browser or screen reader cannot adequately deal with that content. However, that's my personal opinion; you might feel differently, or the legal situation where you are might require you to dumb down your code to accommodate those screen readers. Of course, they might fix the bugs by the time you read this book. In the meantime, it's your responsibility to know your users and the law in your area.

Even more new structures!

You ain't seen nothing yet. Actually, that's untrue: you've seen loads already. So while we're in the zone, let's look at other new elements of HTML5, and some of the changes from HTML 4. We'll look at global attributes allowed on any element, as well as wave "hi" to a few HTML5 features that we won't cover in this book.

Microdata

Microdata is a way to give extra semantics to your content without using more HTML elements. It's similar to __RDFa__ and microformats, but is (arguably) simpler.

HTML5 element categories and content models

HTML 4 divided elements into "block-level" and "inline." These names are gone from HTML5, as they're inherently presentational; they simply reflect the way browsers display them with their default style sheets. There is nothing inherent to any HTML element that is "block" or "inline."

By default, CSS defines every element as[ display:inline]( display:inline) until it's overridden by the browser's default style sheet or the gorgeous design that the sublimely talented designer that you are applies to the markup. (Don't blush, you know you are; everybody says so.)

In HTML5, we find lots of new content models, including phrasing (broadly equivalent to inline) and flow (broadly equivalent to block-level). Some elements (<a>, <ins>, <del>) can be both. You'll also recognize heading content like <h1>..<h6> and sectioning elements like <article>, <section>, <nav>, and <aside>.

There's also embedded (content that imports another resource into the document, or content from another vocabulary that's inserted into the document, such as <audio>, <canvas>, <embed>, <iframe>, <img>, <math>, <object>, <svg>, and <video>), interactive (<a>, <audio> [if the controls attribute is

present], <button>, <details>, <embed>, <iframe>, and <img> [if the usemap attribute is present], <input> [if the type attribute is not in the hidden state], <keygen>, <label>, and <menu> [if the type attribute is in the toolbar state], <object> [if the usemap attribute is present], <select>, <textarea>, and <video> [if the controls attribute is present]), metadata, and others.

Don't get hung up on these. They're pretty intuitive: Apart from the fact that <a> now behaves like <ins> and <del> and can be "inline" or "block" (to use the old HTML 4 parlance), you won't notice anything different from before in terms of styling--particularly if you're using the HTML5 shiv (http://code.google. com/p/html5shiv/) to help old browsers along with the new HTML5 elements until their default presentation is added to the browsers' style sheets.

Microdata is composed of five attributes that can go on any HTML element. The most important are itemscope, itemtype, and itemprop.

itemscope defines the scope of one particular item; it says "this container is all about one single item."

Here is a <div> about this very book:

<div itemscope>

I love that Introducing HTML5 by Bruce Lawson and Remy Sharp ¬(ISBN 0321784421)

</div>

itemtype allows me to specify a vocabulary so a parser or crawler will know what kind of information I'm marking up (this must be an absolute URL):

<div itemscope itemtype=["http://schema.org/Book]("http://schema.org/Book)">

I love that Introducing HTML5 by Bruce Lawson and Remy Sharp ¬(ISBN 0321784421)

</div>

Using itemprop I can assign properties to the content:

<div itemscope itemtype=["http://schema.org/Book]("http://schema.org/Book)">

I love that <span itemprop="name">Introducing HTML5</span>

by <span itemprop="author"> Bruce Lawson</span> and <span itemprop="author">Remy Sharp</span>

(ISBN <span itemprop="isbn">0321784421</span>)

</div>

Notice I've used the properties name for the book title, isbn for

the ISBN, and author twice, for Bruce and that other guy.

The actual value that gets assigned to itemprop depends on the element it's on. It's generally the text content of the element, except:

- If the element also has an itemscope attribute, the value is the item created by the element.
- If the element is a <meta> element, the value is the value of the element's content attribute.
- If the element is an <audio>, <embed>, <iframe>, <img>, <source>, <track>, or <video> element, the value is the element's src attribute, resolved to an absolute URL.
- If the element is an <a>, <area>, or <link> element, the value is the element's src attribute, resolved to an absolute URL.
- If the element is an <object> element, the value is the element's data attribute, resolved to an absolute URL.
- If the element is a <time> element with a datetime attribute, the value is the value of the element's datetime attribute.
Microdata items can be nested, so I could give details for the authors using __vCard__. On the span containing the author name, we give it an itemprop of author, as that's its relationship to the book vocabulary, and we define the span as being a container "about" an individual, so give it an itemscope and an itemtype pointing at the __hCard__ vocabulary:

> This is a silly micro-data example as it gives no further information about our authors than their names; the purpose is to demonstrate the nesting. Much fuller examples can be found in the spec at[ www.whatwg.org/specs/]( www.whatwg.org/specs/) web-apps/current-work/ multipage/microdata. html#mdvocabs.

<div itemscope itemtype=["http://schema.org/Book]("http://schema.org/Book)">

I love that <span itemprop="name">Introducing HTML5</span>

By

<span itemprop="author" itemscope itemtype=
["http://microformats.org/profile/hcard]("http://microformats.org/profile/hcard)">

<span itemprop="fn">Bruce Lawson</span> </span>

and

<span itemprop="author" itemscope itemtype=
["http://microformats.org/profile/hcard]("http://microformats.org/profile/hcard)">

<span itemprop="fn">Remy Sharp</span> </span>

(ISBN <span itemprop="isbn">0321784421</span>) </div>

Microdata is as simple as that for the majority of use-cases. There are, however, two more attributes that we'll mention for completeness.

itemref

Sometimes, you might want to list additional elements for a user agent to crawl in order to find the name-value pairs of the item, because those elements aren't descendents of the element with the itemscope attribute. On the element with itemscope, you can list unique, space-separated tokens that are case-sensitive and correspond to __IDs__ of elements in the same page.

itemid

If you want to, you can use an itemid attribute. This is a globally unique identifier--not just on your website, but on the whole Web. It could, for example, be an ISBN or a URL or anything

that you can guarantee to be unique, really. Doing this sprinkles magical Semantic Web pixie dust all over your website, and crawlers and content aggregators will "know" that your content is talking about the same things as my content because they share the same itemid. (At time of writing, though, the Microdata vocabularies published by Bing, Google, and Yahoo! on schema. org don't use itemid at all.)

If you want to use itemid, you must use a vocabulary that supports global identifiers:

"The itemid attribute must not be specified on elements that do not have both an itemscope attribute and an itemtype attribute

specified, and must not be specified on elements with an itemscope attribute whose itemtype attribute specifies a vocabulary that does not support global identifiers for items, as defined by that vocabulary's specification."

For more information about Microdata, we recommend "Extending HTML5--Microdata" by Oli Studholme

[http://html5doctor.com/microdata/](http://html5doctor.com/microdata/)

"Microdata Tutorial" by Tab Atkins, Jr.

www.xanthir.com/blog/b4570

"Using Multiple Vocabularies in Microdata" by Jeni Tennison

www.jenitennison.com/blog/node/161

The Microdata DOM API

Microdata also has an associated DOM API to manipulate items and properties which gives the document.__getItems__() method to grab a nodelist containing Microdata items on a page. Without an argument, the method gets all the items on a page, or passing an itemtype URL returns only items with that itemtype.

At time of writing, only pre-release versions of Opera 12 support the DOM API.

<aside>

In Chapter 1 you saw <aside> used to mark up sidebars. It represents "a section of a page that consists of content that is tangentially related to the content around the aside element, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography. The element can be used for typographical effects like pull quotes or sidebars, for advertising, for groups of nav elements, and for other content that is considered separate from the main content of the page."

Using an <aside> inside an <article>, for example, is the right place for tangentially related information or pull quotes about that article, but not, we hasten to add, page-wide navigation.

<aside> has an implied ARIA role of note, but can be given role="complementary" or (if it surrounds a search form) role="search".

{{figure 2.19
Figure 2.19 How we'd like our web page to look.
}}

{{figure 2.20
Figure 2.20 How our bidi page actually looks. Note
}}

the numeral "5" has been separated from the word "reviews." The content is now unintelligible.

<bdi>

The spec says that <bdi> "represents a span of text that is to be isolated from its surroundings for the purposes of bidirectional text formatting." Huh? I asked Richard Ishida (@r12a on Twitter-- follow him!), the W3C's internationalization lead, to explain this to me, and he was kind enough to write a blog post in response (http://rishida.net/blog/?p=564), which I have condensed here with his permission.

The HTML5 specification contains a bunch of new features to support bidirectional text in web pages. Languages written with right-to-left scripts--such as Arabic, Hebrew, Persian, Thaana, Urdu, and so on--commonly mix in words or phrases in English or some other language that uses a left-to-right script. The result is called bidirectional or bidi text.

HTML 4.01, coupled with the Unicode Bidirectional algorithm, already does a pretty good job of managing bidirectional text, but there are still some problems when dealing with embedded text from user input or from stored data.

Here's an example where the names of restaurants are added to a page from a database. This is the code, with the Hebrew shown using ASCII:

<p>Aroma 3 reviews</p> <p>PURPLE PIZZA 5 reviews</p>

Figures 2.19 and 2.20 show what you'd expect to see, and what you'd actually see, respectively.

The problem arises because the browser thinks that the "-5" is part of the Hebrew text. This is what the Unicode Bidi Algorithm tells it to do, and usually it is correct. Not here though.

So the question is how to fix it? The trick is to use the <bdi> element around the text to isolate it from its surrounding content. (bdi stands for "bidi-isolate.")

<p><bdi>Aroma</bdi> 3 reviews</p> <p><bdi>PURPLE PIZZA</bdi> 5 reviews</p>

The bidi algorithm now treats the Hebrew and "5" as separate chunks of content, and orders those chunks according to the direction of the overall context (in this instance, from left to right).

You'll notice that the example above has bdi around the name Aroma too. Of course, you don't actually need that, but it won't do any harm. On the other hand, it means you can write a script in something like PHP that says:

foreach $restaurant echo "<bdi>".$restaurant['name']." ¬</bdi> %1 reviews";

This way you can handle any name that comes out of the database, whatever language it is in.

Using the dir attribute with bdi

The dir attribute can be used on the <bdi> element to set the base direction. With simple strings of text like PURPLE PIZZA you don't really need it, however if your <bdi> contains text that is itself bidirectional you'll want to indicate the base direction.

Before HTML5, you could only set the dir attribute to ltr or rtl. The problem is that in a situation like the one described above, where you are pulling strings from a database or user, you may not know which of these to use.

That's why HTML5 has provided a new auto value for the dir attribute, and bdi comes with that set by default. The auto value tells the browser to look at the first strongly typed character in the element and work out from that what the base direction of the element should be. If it's a Hebrew (or Arabic, and so on) character, the element will get a direction of rtl. If it's, say, a Latin character, the direction will be ltr.

In rare instances this may not give the desired outcome, but in the vast majority of cases it should produce the expected result.

Note that this isn't implemented anywhere yet, but as information about it is so scarce, we've included it here.

<details>

I'm very fond of the <details> element. It's cool because it introduces native support for a common behaviour--an expanding/ collapsing area--thereby removing the need for custom JavaScript (or, something I've seen on far too many sites to be funny, pulling in the full jQuery library).

60

> The <details> element isn't restricted to purely textual markup--it could be a login form, an explanatory video, a table of source data for a graph, or a description of the structure of a table for those who use assistive technology, have learning disabilities, or who (like me) simply don't "get" numbers.

<details>

<summary>Photograph details</summary>

<p>Photograph taken on <time datetime=2009-12-25>Xmas ¬Day 09</time> with a Canon __IXUSi__.</p> <p><small>Copyright Bruce Lawson,

¬ <address[>bruce@brucelawson.co.uk](>bruce@brucelawson.co.uk)</address></small>.</p>
</details>

The contents of the descendant <summary> element are focusable and act as a control that, when activated by mouse or keyboard, expand or collapse the remainder of the element. If no <summary> element is found, the browser supplies its own default control text, such as "details" or a localised version. Browsers will probably add some kind of icon, such as a down arrow, to show that the text is "expandable."

<details> can optionally take the open attribute to ensure that the element is already open when the page is loaded:

<details open>

At time of writing, <details> is only supported by Google Chrome 12. Use with care though, and test it well, as it has accessibility problems: it can't be controlled with a keyboard so requires a mouse. Hopefully this will be fixed in a future version of Chrome.

<figure>

I've always felt a bit semantically grubby when adding a caption to explain a picture or to give attribution to the photographer, because the only way to do it has been with text that runs into surrounding content, with no way to explicitly associate it with the image. There simply haven't been any markup constructs for this before. Perhaps I'm just weird, but that's why I'm very glad to see the <figure> element that wraps an image (or a video, or block of code, or a supporting quotation) and its caption, which goes in the <figcaption> element:

<figure>

<img src=welcome.jpg

>

<figcaption>

Bruce and Remy welcome questions <small>Photo &copy; Bruce's mum</small> </figcaption>

</figure>

{{figure 2.21
Figure 2.21 <figure> and <figcaption> elements with some CSS3 designer bling.
}}

Styling this markup can produce some nice effects (Figure 2.21).

Notice that there is no alt attribute on the image. In the first edition, I had added a blank alt="", but this was incorrect.

In figures where the figcaption text tells you all you need to know ("Pippa Middleton and Remy Sharp pose on the red carpet at the premier of the Jane Austen movie Pride and __ECMAScript__"), don't duplicate this in alt text because duplicated content can quickly become very annoying. Duplicated content can quickly become very annoying.

In the first edition, I tried to avoid duplicated content (which can quickly become very annoying) by also including alt="" on the <img> element. But if an image has empty alt text it is regarded as having an implied ARIA role=presentation (only there to enhance presentation). This removes the element from the page's accessibility tree (no user agent does this, yet, but that's the general plan).

As the image is not purely presentational (if it were, you wouldn't mark it up as a figure or give it a caption), you shouldn't have empty alt, you should use no alternate text at all, for example.

Steve Faulkner has written a very useful document "HTML5: Techniques for providing useful text alternatives" (that is a First Public Working Draft, therefore very, very susceptible to change) in which he writes:

"Circumstances in which it is not appropriate to use an empty or null alt attribute: An image is contained within a figure element and has an associated caption provided using the figcaption element." (http://dev.w3.org/html5/alt-techniques/)

On the other hand, you may think that the example above needs alt text <img src=welcome.jpg alt="Bruce and Remy glower menacingly into the camera"> because otherwise the joke isn't communicated to a screen reader user.

As an accessibility bonus it's useful (but not mandatory) to add ARIA attributes to associate the image with the caption until browsers "understand" the figure element and do this automatically.

When there is no alt text, use aria-labelledby to associate the id of the figcaption to the img:

<figure>

<img src=welcome.jpg aria-labelledby=figcap219> <figcaption id=figcap219>

Pippa Middleton and Remy Sharp pose on the red carpet at ¬the premier of the Jane Austen movie <cite>Pride and

¬ __ECMAScript__</cite>

</figcaption></figure>

If there is alt text, use aria-describedby:

<figure>

<img src=welcome.jpg

alt="Bruce and Remy glower menacingly into the camera" aria-describedby=figcap219>

<figcaption id=figcap219>

Bruce and Remy welcome questions

<small>Photo © Bruce's mum</small> </figcaption></figure>

HTML5 and alt text on images

There has been much weeping and lamentation in the streets about the fact that, in certain circumstances, the validator won't punch you for omitting the alt attribute on <img> (although I will punch anyone referring to it as "the alt tag"):

- The presence of <meta name=generator> makes missing alt conforming. The presence of title makes missing alt conforming.
- The presence of figcaption makes missing alt conforming.
I recommend that 99.99 percent of the time, you should continue to use alt with an image, with purely decorative images getting empty alt="". An occasional exception will be as we've discussed with images in <figure>. If the function of the image is exactly expressed in the <figcaption>, use no alt at all. The other 0.01% is when you're writing a template for automatically generated web pages that import images where it's impossible to get alt, for example, automatically including stills from a live webcam, in which case use <meta name=generator> in the head.

<mark>

The <mark> element allows you to do the markup equivalent of using a highlighter pen to bring out some words on a printed page. It's not the same as emphasis--for that you use <em>. But if you had some existing text and wanted to bring something to the fore that isn't emphasised in the text, you could use <mark> and style it to be italics, or with a yellow highlighter-pen background colour. In print, you'll often see the phrases "my italics" or "emphasis added."

The spec also says, "When used in the main prose of a document, it indicates a part of the document that has been highlighted due to its likely relevance to the user's current activity."

As an illustration, on my own site, I use an adapted version of Stuart Langridge's searchhi script (www.kryogenix.org/code/ browser/searchhi/), which checks to see if the referrer to a page was a search engine and the search terms are in the query string. If they are, the script walks the DOM and surrounds each instance of a search term with a <mark> element, which is then styled a pretty pink. It would have been wrong to wrap these search terms in <strong> or <em> as they're not emphatic--and this would have changed the meaning of the content of our page--but are relevant to the user's current activity: arriving at a page on our site looking for information about a certain search term.

<ruby>, <rt>, <rp>

The <ruby> element is a useful addition for those writing content in some Asian languages. Daniel Davis has a very useful article, "The HTML5 <ruby> element in words of one syllable or less" (http://my.opera.com/tagawa/blog/the-html5-ruby-elementin-words-of-one-syllable-or-less), in which he explains how it works, along with the related <rt> and <rp> tags, in the context of Japanese (used with kind permission):

Any piece of Japanese text (banner ad, article, legal doc, and so on) uses a combination of kanji, hiragana, and katakana writing systems. It is sometimes the case that people reading the text can't read the kanji, especially because kanji characters can have more than one pronunciation. People and place names are one example of kanji having numerous or irregular pronunciations.

can be pronounced "nichi," "hi," or "ka" can be pronounced "hon" or "moto"

can be pronounced "nihon" or "nippon"

{{figure 2.22
Figure 2.22 In supporting browsers, ruby text is
}}

shown above main text. In nonsupporting browsers, ruby text is shown next to main text but in parentheses.

To help the reader, sometimes the pronunciation is written above the kanji using the hiragana alphabet. This is called furigana in Japanese and ruby in English (from the name of the small 5.5 pt type size used for similar sorts of annotations in British print tradition). It is often used in newspapers and books but not so much on websites, due to the difficulty of squeezing miniature text above larger text on a single line. The <ruby> element aims to solve this.

According to the current HTML5 spec, the <ruby> element is an inline element and is placed around the word or character you'd like to clarify, like so:

<ruby>  </ruby>

By itself this does nothing, so you add the pronunciation either for each character or, as in this case and our personal preference, for the word as a whole. For this, you use the <rt> tag, meaning ruby text.

<ruby>  <rt> </rt></ruby>

You could leave it like that and supporting browsers would show the hiragana pronunciation above the kanji text, but nonsupporting browsers would ignore the tags and show both the text and its pronunciation side by side. To solve this, you have another tag, <rp>, meaning ruby parentheses, which cleverly hides characters (namely parentheses) in supporting browsers. This means you can write the pronunciation in parentheses, which nonsupporting browsers will show, and supporting browsers will continue to show the pronunciation without parentheses above the main text (Figure 2.22).

<ruby> <rp>(</rp><rt>  </rt><rp>)</rp></ruby>

<wbr>

In Netscape 4 and now standardized by HTML5 to great rejoicing, the <wbr> element tells a browser it may (but is not required to) insert a line break here if it needs somewhere to break a line.

Redefined elements

{{figure 2.23
Figure 2.23 An <address> containing a QR code as contact details.
}}

HTML5 redefines the semantics of some existing elements as well as adding new ones. Here are a few old friends: some have radically changed, others have simply finessed their hairstyles.

<address>

As in HTML4, <address> is for contact details of the author, not as a generic element for postal addresses.

What's new is that you can have multiple addresses in a document, one inside each <article>. Author information associated with an <article> element does not apply to nested <article> elements, so a blog post in an <article> can have an <address> for its author, and each blog comment (which you remember is a nested <article>) can have the <address> of its commenter.

Now we're all riders of the Information Superhighway, and we probably use electronic methods to contact authors, so contact details can be email address, postal address, or any others. These can be marked up as a microformat, __RDFa__, or Microdata if you wish (Figure 2.23).

<address>

<a href=["http://introducinghtml5.com]("http://introducinghtml5.com)"> <img src=qr.png alt="">

Bruce Lawson, Remy Sharp</a> </address>

Tangentially, formatting addresses (along with adding line breaks to poetry, lyrics, and code samples) is one of the few reasons remaining to use the <br> element:

<address>

Dunhackin<br>

123 Standards Boulevard<br> Semantichester<br>

UK<br>

</address>

<cite>

In HTML 4, the <cite> element could be used to mark up the name of a speaker:

As <cite>Harry S. Truman</cite> said,<Q lang="en-us"> ¬The buck stops here.</Q>

HTML5 disallows this: "A person's name is not the title of a work-- even if people call that person a piece of work--and the element must therefore not be used to mark up people's names."

This is bonkers. It makes existing content that conforms to the rules of HTML 4 nonconforming to the rules of HTML5, although it will never be flagged as invalid by a validator, as a machine has no way of knowing that "Harry S. Truman" is a name rather than the title of a biography called "Harry S. Truman."

In his article, "Incite a Riot," <cite>Jeremy Keith</cite> wrote, "Join me in a campaign of civil disobedience against the unnecessarily restrictive, backwards-incompatible change to the <cite> element (http://24ways.org/2009/incite-a-riot)."

I agree. Use <cite> for names if you want to. <dl>

In HTML 4, <dl> was a definition list containing a term and one or more definitions for that term. This was nice and straightforward, but then the spec got itself all muddy and confused, as it also mentioned the potential use of <dl> to mark up dialogues, complete with code examples to that effect. It was regularly misused to mark up any name and value pairs regardless of whether one defined the other.

HTML5 widens the element to be "an association list consisting of zero or more name-value groups . . . Name-value groups may be terms and definitions, metadata topics and values, or any other groups of name-value data." Here's an example listing the books in Remy's collection, using <dt> and <dd> to group title and author(s).

<dl>

<dt>History of French plastic sandals</dt> <dd>Phillipe Philloppe</dd>

<dt>J-Lo's plastic surgery: a profile</dt> <dd>Hugh Jarce</dd>

<dt>The Orpheus and Eurydice myth</dt>

<dd>Helen Bach</dd>

<dt>The Proctologist and the Dentist</dt> <dd>Ben Dover</dd>

<dd>Phil __McCavity__</dd>

</dl>

<em>, <i>

Use <em> to mark up emphasis of the kind that subtly changes the meaning of a sentence; if the question is "Did you say you live in Paris?" the answer might be marked up as

<p>No, my <em>name</em> is Paris. I live in <em>Troy</em>.
Cloth-ears.</p>

If you have relative levels of importance, you can nest <em> elements to make the contents extra emphatic.

The spec tell us that the <i> element "represents a span of text in an alternate voice or mood, or otherwise offset from the normal prose, such as a taxonomic designation, a technical term, an idiomatic phrase from another language, a thought, a ship name, or some other prose whose typical typographic presentation is italicized."

Here are some examples of <i> where <em> would not be appropriate:

<p>The <i>Titanic</i> sails at dawn.</p>

<p>The design needs a bit more <i lang=fr>ooh la la</i>.</p> <p>You, sir, deserve a jolly good kick up the <i>gluteus maximus</i>!</p>

<hr>

The <hr> element is now media-independent and indicates "a paragraph-level thematic break." A commenter on __HTML5doctor__.com put it nicely: "It's the markup equivalent of the '* * *' that is often used in stories and essays." We were about to write

it off as a historical curiosity when fellow HTML5 Doctor Oli Studholme wrote, "<hr> is used as a section separator quite frequently in Japanese design. They're generally hidden via CSS but visible when viewed on __cHTML__ cell phone browsers, which only support very basic CSS and don't get the visual design (and with it the visual separation of sections)."

Unless your audience has significant numbers of users of these phones, we recommend you use sectioning content and headings instead, with CSS for pretty dividers and forget about <hr>. That way you have less markup, and besides, it's hard to style <hr> consistently across browsers.

<ol>

Our old friend the unordered list hasn't been redefined, but it does have two new attributes.

In HTML 4, the start attribute on <ol> was deprecated, as it was deemed presentational. Luckily, HTML5 reverts this wrong decision. If you want an ordered list to start at line five rather than line one, use:

<ol start=5>

Something nice that isn't yet implemented in any browser is the reversed attribute. Consider the following example:

<h3>Top five dreamy mega-hunks</h3> <ol reversed>

<li>Brad Pitt</li> <li>George Clooney</li> <li>Orlando Bloom</li> <li>Remy Sharp</li> <li>Bruce Lawson</li>

</ol>

This creates a list that counts down from five (Mr. Pitt) to one (me). Sorry, Brad, George, and Orlando--but what do you guys know about HTML5?

<s>

In HTML 4.01, we had the <strike> and <s> elements to present some text with a line through it. HTML5 retains <s> to represent content that is no longer accurate or no longer relevant and that therefore has been "struck" from the document. You'd use it to show a pre-special offer price:

<p>Photograph of Remy Sharp in mankini. <s>&pound;100</s> ¬Now: 12 pence.</p>

<small>

The <small> element has been completely redefined, from a generic presentational element to make text appear smaller

to actually representing "small print," which "typically features disclaimers, caveats, legal restrictions, or copyrights. Small print is also sometimes used for attribution, or for satisfying licensing requirements."

You might not notice this redefinition, as your browser will probably render the content in smaller type, just as before. But the new semantic means that <small> also corresponds to the really quickly spoken part at the end of radio advertisements, so a screen reader might mimic that for its default aural rendering.

If the whole page is a "legalese" page, don't use <small>. In that case, the legal text is the main content, so there is no need to use an element to differentiate the legalese. It's only for short runs of text. <small> has no bearing on <strong> or <em> elements.

<strong>, <b>

The <strong> element represents strong importance for its contents but, unlike <em>, it does not change the meaning of the sentence. For example,

<p><strong>Warning! This banana is dangerous.</strong></p>

You can nest strong elements to make them extra-important.

The <b> element "represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede."

For example:

<p>Remy never forgot his fifth birthday--feasting on ¬<b>powdered toast</b> and the joy of opening his gift: ¬a <b>Log from Blammo!</b>.</p>

<u>

The <u> element is another one that used to be presentational but has now been given a New! Improved! semantic meaning, in what feels more like a mopping-up exercise than a useful definition.

The spec says it "represents a span of text with an unarticulated, though explicitly rendered, non-textual annotation, such as labeling the text as being a proper name in Chinese text (a Chinese proper name mark), or labeling the text as being misspelt."

Removed elements

Some elements you may know from HTML 4 have been made completely obsolete in HTML5, such as <applet> (use <embed> instead), <big>, <blink>, <center>, <font>, and <marquee>. They will not validate and must not be used by authors. Frames are gone (but <iframe> remains). Good riddance.

HTML5 browsers must still render these dear departed elements, of course, as there are plenty of them still out there in the wild. But you must avoid them as if they were tarantulas, zombies, man-eating tigers, plutonium sandwiches, or Celine Dion songs.

Global attributes

There are several new global attributes, which can be added to any element. They are covered in this section.

accesskey

The accesskey attribute allows a developer to specify a keyboard shortcut that activates or focuses the element. It was added to HTML 4 to promote accessibility. Because of discoverability problems, but primarily because most possible combinations conflict with keystrokes in assistive technologies, it was rarely used.

Because HTML5 is for web applications, and power users like to use keyboard shortcuts, accesskey isn't removed from HTML5 and is now allowed on any element.

To prevent clashes with other applications or the browser's own keyboard shortcuts, you can now specify a number of alternatives in the accesskey attribute. The spec gives this example:

<input type="search" name="q" accesskey="s 0">

explaining that "the search field is given two possible access keys, 's' and '0' (in that order). A user agent on a device with a full keyboard might pick Ctrl+Alt+S as the shortcut key, while a user agent on a small device with just a numeric keypad might pick just the plain unadorned key 0."

contenteditable

Invented by Microsoft, and reverse-engineered and implemented by all other browsers, contenteditable is now officially part of HTML5.

This adoption of contenteditable means two things for browsers: first, users can edit the contents of elements with this attribute, so the element must be selectable and the browser must provide a caret to mark the current editing position; second, you can make the text bold, change the font, add lists, headings, and so on. contenteditable is a Boolean attribute, so it can be set to true or false. Although markup capitalisation is irrelevant, the DOM attribute (if you were to set it programmatically through JavaScript) requires __contentEditable__ (note the capital E). The DOM also has __isContentEditable__ to assess whether an element is editable--since the __contentEditable__ flag could have been inherited from a parent element.

You can also set document.__designMode__ = 'on' (notice, not 'true') to enable the entire document to be editable. This can only be done using JavaScript--there is no equivalent attribute that can be written in your HTML.

Finally, any content that is selected (highlighted) by the user can have a number of commands run against it, such as document. __execCommand__('bold'). Typical keyboard commands to make text bold or italic (such as CTRL+B and CTRL+I respectively on Windows/Linux) affect the DOM in the editable element, adding <b> and <i> around them.

If you want to use contenteditable for some form of CMS, you will want to save the changes to your server at some point. There's no particular API method for doing this, but since your user's changes have modified the DOM, you need to send the __innerHTML__ of the editable element (or entire document if using __designMode__) back to the server for saving in your CMS.

data-* (custom data attributes)

HTML5 allows custom attributes on any element. These can be used to pass information to local scripts.

Previously, to store custom data in their markup, authors

would do something annoying like use classes: <input class="spaceship shields-5 lives-3 energy-75">. Then your script would need to waste time grabbing these class names, such as shields-5, splitting them at a delimiter (a hyphen in this example) to extract the value--all very hacky and arguably an abuse of the class attribute, which is intended (according to HTML 4.01) as a hook for styling or for "general purpose processing by user agents."

In his 2007 book, ppk on JavaScript, Peter-Paul Koch explains how to do this and why he elected to use custom attributes in some HTML 4 pages, making the JavaScript leaner and easier to write but also making the page technically invalid. As it's much easier to use data-shields=5 for passing name/value pairs to scripts, HTML5 legitimises and standardises this useful, realworld practice and gives us a simple, standardised API to easily access and manipulate these custom attributes.

When the data-* attributes are fully supported in a browser, JavaScript can access the properties using element.dataset.foo (where the data-foo attribute contains the value).

This is currently supported in all browsers except Internet Explorer, but the polyfill at[ http://gist.github.com/362081]( http://gist.github.com/362081) can help with that.

Otherwise scripts can access the values via the traditional get/__setAttribute__ methods. The advantage of the dataset property over __setAttribute__ is that it can be enumerated a lot more easily. Say, for instance, you needed to get all the values stored in the data-* attributes; using the native functionality the code is straightforward and as you'd expect (without any optimisation):

var values = [];

for (var key in element.dataset) {

  values.push(element.dataset[key]);

}

However, to do this today, although the code has the same result, it's not so accessible to newer developers or folk that are less savvy with JavaScript and the DOM:

> Custom data attributes are only meant for passing information to the site's own scripts, for which there are no more appropriate attributes or elements. The spec says "These attributes are not intended for use by software that is independent of the site that uses the attributes" and are therefore not intended to pass information to crawlers or thirdparty parsers. That's a job for microformats, Microdata,

or __RDFa__.

var attributes = el.attributes, values = [];

for (var i = 0; i < attributes.length; i++) {

if (attributes[i].name.__indexOf__('data-') === 0) {

    values.push(test.attributes[i].__nodeValue__);

}

When fully implemented in browsers, setting a dataset attribute automatically sets the content attribute on the element giving you a shorthand syntax for setting custom data. So instead of having to do

element.__setAttribute__('data-author', 'Remy and Bruce');

You can simple execute

elemenent.dataset.author = 'Remy and Bruce';

This syntax will automatically set the attribute on the DOM node as well as change the dataset.name property.

draggable

draggable indicates that the element can be dragged using the drag-and-drop API (see Chapter 8).

hidden

This hidden attribute is analogous to aria-hidden, which tells the browser that the content of this element shouldn't be rendered in any way. It hides the content, but keeps it "in the wings," so that, for instance, you could use JavaScript later on to remove the attribute and cause the element to "pop" into being.

Quoting the specification (rather than attempting to paraphrase it any further): "The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation--one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation--if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers."

}

Even if you know that you'll be "unhiding" stuff later with some scripting, you should treat hidden stuff as if it literally wasn't there. So don't add links pointing to content that's hidden

and don't tie other elements to it with aria-describedby or aria-labelledby.

id

You don't need us to explain what our old chum id is. But now you can begin the value of id with a digit, just like you always have been able to do with class. Yay to the max, that's phat, as people a quarter of my age probably say.

itemscope, itemprop,

itemtype, itemref, itemid

These attributes are associated with the Microdata specification.

role, aria-*

As you've already seen, HTML5 treats WAI-ARIA as legal additions to the language--meaning they'll quite happily validate.

spellcheck

This Boolean attribute tells the browser to check the element's spelling and grammar--generally, an <input> or <textarea>, but it could be anything because anything can be set to be contenteditable. If it's missing, "the default state indicates that the element is to act according to a default behavior, possibly based on the parent element's own spellcheck state."

tabindex (=-1)

tabindex is a largely archaic concept that allows you to specify the order in which elements are focused when the user navigates a page with the keyboard (traditionally using the Tab key, though some browsers--most notably Opera--may use different key combinations for this).

This was quite popular when sites were built using deeply nested layout tables in which the document order of focusable elements would often be markedly different from its visual

rendering order and logical tab order. Because no one above the level of WYSIWYG-wielding wannabe has used tables for layout since Mozart went stegosaurus hunting, nowadays this

is not usually necessary. The default tab order is determined

by the order in which elements appear in your markup, so a properly ordered and structured document should never require additional tabbing hints.

However, tabindex does have a useful side effect. Normally, only links, form elements, and image map areas can be focused via the keyboard. Adding a tabindex can make other elements also focusable, so executing a focus() command from JavaScript would move the browser's focus to them. However, this would also make these elements keyboard-focusable, which may not be desirable.

Using a negative integer (by convention, tabindex=-1) allows the element to be focused programmatically, "but should not allow the element to be reached using sequential focus navigation."

It's very useful in overcoming a bug in IE whereby, under some circumstances, elements such as headings that were targets of in-page links were never focused for screen reader users, leaving the information inaccessible. (See[ www.juicystudio.com/]( www.juicystudio.com/) article/ie-keyboard-navigation.php for more information.) In HTML 4, "-1" was an invalid value for the attribute, and the attribute itself was invalid on any element other than form fields and links. However, as it works in browsers now and it solves a real problem, HTML5 legalises it everywhere. Yay!

Removed attributes

<table border=...>

Of course, there's no question that someone like you wouldn't use tables to lay out a page, but just in case you are maintaining or tweaking these old-school monsters, there are only two allowed values for the border attribute: the empty string and

"1". These simply give a hint to user agents that the table is for layout. A better way to do this, however, is with the newfangled ARIA role=presentation, which is interesting as its children don't inherit it--so a table can be marked as presentational, but its contents (a form inside one of the table cells, for instance) does

not also get marked as presentational in the eyes of screenreaders and other ARIA-consuming user agents.

Of course, if you need groovy borders for your data tables, use CSS. This is really here just for backwards compatibility.

<table summary=...>

Previous versions of HTML had a summary attribute on <table>, which was not to be rendered visually but was purely "for user agents rendering to non-visual media such as speech and Braille." This is now nonconforming. One reason for this is that data that can't be seen can fall out of step with the visual data that it describes. This might happen when a harassed developer updates the data in the table and, because the hidden summary is invisible to a quick visual check, fails to update the summary as well to correspond with the visible data. An incorrect summary of the table data is worse than no summary at all.

It's been argued that it would be better to require user agents to render table summaries visually, but unfortunately WCAG 1, the original web accessibility guidelines, required a table summary, so there are many layout tables with the helpful summary "This is a layout table" and it's unlikely that the Web would be improved by revealing each of those.

It seems to me that if a website has a structure complex enough that it needs summarising to visually impaired users, non-screen reader users might also benefit from that information. Therefore, the spec gives numerous suggestions for presenting this information visually: surrounding the table, in the table's caption, in a <details> element, next to the table in the same <figure>, next to the table in a <figcaption>, or simply in prose.

<img longdesc=...>

The attribute longdesc was a very rarely used attribute on images that pointed to a separate page which described the image

in detail. It's been removed from HTML5, largely because few authors ever used it, and few of those who did authored it correctly. Nevertheless, it is much beloved by screen reader users, 60 percent of whom say it's "somewhat" or "very" useful (http://webaim.org/projects/screenreadersurvey3/#longdesc) and no comparable method exists to provide the same form of extended description, so you'll need to use other mechanisms (such as the <details> element) to describe an image.

Features not covered in this book

For completeness, here are some of the most interesting features of HTML5 that, for reasons of page count or lack of implementation, aren't discussed further.

<embed>

Of course <embed> is well-known and has been used for years, but was always an outlaw element that never validated. But like that other outlaw, Robin Hood, it was widely supported because it performed a useful function: It's the only way to get plugins such as Flash to work reliably in all browsers, which explains

its overwhelmingly common usage (see 2008 stats at http:// dev.opera.com/articles/view/mama-plug-ins/). Because of this, there's no reason to keep it from validating. HTML5 paves that particular cowpath and finally includes it into the formal language specification.

But hang on. Isn't HTML5 supposed to replace all these pluginbased technologies? Contrary to the sensationalist headlines of some journalists, HTML5 won't magically replace plugins overnight, and now we can embed them into HTML5 without incurring the wrath of the validator.

<keygen>

This element, which is already well supported in all browsers other than the big IE elephant in the room, is used in situations where your form needs to send a public key. Take a look at[ http://en.wikipedia.org/wiki/Public_key]( http://en.wikipedia.org/wiki/Public_key) to learn more about public-key cryptography.

And if you're still lost, you don't actually need this element!

<menu>, <command>

These are exciting elements that allow you to define toolbars or context menus for your application, with icons and associated commands that execute scripts when activated. They're cooler than a bucket full of Lou Reeds. However, no browser yet supports them, so we don't discuss them further.

Summary

<style scoped>

The scoped attribute on a style element tells the browser

to apply the styles to the element that the <style scoped> element is in, and its children. Thus, it is found inside elements in the document's <body> rather than only in the <head> where style elements have hitherto been confined. This allows for highly localised styling right inside your HTML; for instance, an <article> that contains a scoped style block can be syndicated and retain its special styles.

However, no browser supports it yet.

Phew, that was quite a ride, wasn't it? You've seen a lot of new structures, new elements, and quite a few changes to existing elements. If you've studied our markup examples carefully, you also know the favoured weaponry of fairies, so beware if you're a goblin or an orc.

HTML5 allows us to mark up common website structures with dedicated elements, rather than empty <div> or <span> elements. However, these elements are still completely necessary parts of the language. Just as with HTML 4, you should use these generic containers when there are no more appropriate elements--but now you have a larger arsenal of semantically more meaningful elements to choose from. You've also seen that some of these new elements have conceptually built-in roles to help assistive technologies. However, while we're in this transitional period and browser (and, more importantly, screen reader/assistive technology) support for these built-in roles may still be lacking, you can (validly and legally) add extra ARIA information.

It probably seems pretty complex, but take my word for it: as you use these new constructs, they soon become much easier to understand ... so get stuck in!