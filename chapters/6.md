# Data Storage

Data Storage is fundamental in nearly all applications, web or desktop. This can include storing a unique key to track page impressions, saving usernames and preferences, and so on. The list is endless.

Up until now, storing data in a web app required you to either store it on the server side and create some linking key between the client and the server--which means your data is split between locations--or store it in cookies on the client.

Cookies suck. Not the edible ones, the ones in the browser. They're rubbish. There's a number of issues with cookies that make them a pain to work with. On starting any new project that requires cookies, I'll immediately go hunting for my cookie JavaScript library. If I can't find that, I'll head over to Peter-Paul Koch's cookie code, and copy and paste away.

> Get PPK's cookie code at [quirksmode.org](http://www.quirksmode.org/js/cookies.html).

Looking at how cookies work, they're overly complicated. Setting a cookie in JavaScript looks like this:

```js
document.cookie = "foo=bar; path=/";
```

That's a session-based cookie. Now, if I want to store something for longer, I'll have to set it in the future, and give it a specific lifetime (and if I want it to persist, I'll have to keep setting this to be n days in the future):

```js
document.cookie = "foo=bar; path=/; expires=Tues 13 Sept 2010 12:00:00";
```

The time format is important too, which only causes more headaches. Now, the icing on the horrible-tasting cookie--to delete a cookie, I need to set the value to blank:

```js
document.cookie = "foo=; path=/";
```

In fact, the cookie isn't really deleted, it's just had the value changed and had the expiry set to the current session (that is, when the browser is shut down). Delete should really mean delete.

Cookies don't work because they're a headache. The new storage specifications completely circumvent this cumbersome approach to setting, getting, and removing data by offering a clean API.

Being British though, I feel I need to add a caveat to the "cookies suck" statement. But fear not--it's only a small caveat. If you need to share client-side data with the server side, cookies are the right solution because they append themselves to every request automatically. If you don't, then you want a client-side storage engine. To me, Web Storage evolved as cookies should have, but Web Storage has even more functionality, hence the evolution. So with my caveat aside, let's look at what today's browsers have in store for us (pardon the pun)!

## Storage options

There are three options when it comes to storing data on the client side:

- Web Storage--supported in all the latest browsers--[ http://www.w3.org/TR/webstorage/]( http://www.w3.org/TR/webstorage/)
- Web SQL Database--supported in Opera, Chrome, and Safari--[ http://www.w3.org/TR/webdatabase/]( http://www.w3.org/TR/webdatabase/)
- IndexedDB--at the time of writing, experimental support in Chrome 12, Firefox 5, and Internet Explorer 10--[ http://www.w3.org/TR/Indexeddb/]( http://www.w3.org/TR/Indexeddb/)

Conveniently, the name Web SQL Database instantly gives you a clue as to how it works: It uses SQL-based syntax to query a local database. You may think that's great as you already know SQL. The small potential issue is that the specification currently has a stonking great sign notifying readers that the spec is no longer being maintained. However, as it has such good support, particularly in the mobile space, I want to show you how to use the API. In addition, Google uses Web SQL Database in its mobile version of Gmail, so I'm confident the technology will remain in browsers for quite some time to come.

IndexedDB's name is less descriptive, though you'd probably be able to guess how it works. IndexedDB is a document data store, akin to today's popular "NoSQL" databases, like MongoDB. Essentially you have a key and you can store any data type against that key, rather than having a set number and type of columns as per traditional SQL databases. Interestingly, IndexedDB puts events at the core of how you work with the API. We'll talk more about that toward the end of the chapter.

Web Storage is a much simpler system in which you associate a key with a value, compared to the amount of code required when working with Web SQL Database or IndexedDB. Support for the Web Storage API is much better than the current alternatives--but this should change with time leaving us with a simple storage method (Web Storage) and larger data storage (IndexedDB as support flushes through to the rest of the browsers). I'll look at all three of these APIs, how they work, and how to debug data in each system.

Web Storage typically has a limit of 5 MB (but browsers will generally ask permission from the users if more than 5 MB is required, and ask whether they want to allow the website to go beyond the current default).

On the other side of the fence, the Web SQL Database specification doesn't talk about limits, and it's up to the author to try to gauge the total size of the database when it's created.

Then there's IndexedDB spec that doesn't mention limitations (on the other, other side of the fence?), but it appears as Chrome has a limit of 5 MB. It's unclear what the limits are in Firefox and IE10. I am sure that as this specification gets better support in the browsers, these limits will be well documented.

All data is tied to document origins which is made up of the protocol, plus host, plus port number (which defaults to port 80)-- which means that data on[ http://remysharp.com]( http://remysharp.com) cannot access data on the secure version on[ https://remysharp.com]( https://remysharp.com).

In either case, the browser will throw an exception error if the API isn't able to write the data, but I'll focus on smaller applications where the data stored is around the 100 KB mark.

## Web Storage

> When I'm referring to windows having access, I'm referring to the window object. This is usually bound to a particular origin (protocol + host + port) and applies to browser windows and tabs. Just in case you were confused!

In a nutshell, the Web Storage API is cookies on steroids (but do refer to my caveat previously if this upsets you). One key advantage of this API is that it differentiates between session data and long-term data. If you set a "session" cookie (that is, one without expiry data), that data item is available in all windows that have age, on the other hand, allows you to define a `sessionStorage` that really only refers to the particular window/tab the user is currently in. Once it's closed, the data disappears, rather than sticking around until the entire browser is closed.

The storage API offers two types of storage: `sessionStorage` and `localStorage`.

> Cookies on steroids versus regular cook-ies: IE6 supports only 20 cookies per domain and a maxi-mum size of 4 KB per cookie. Web Storage has no maximum number of items that can be stored per domain, and it limits the aggregate size to upwards of 5 MB.

If you create data in `sessionStorage`, it's available only to that window until the window is closed (when the session has ended). If you opened another window on the same domain, it wouldn't have access to that session data. This is useful to avoid having data from a session "leak" across different windows.

`localStorage` data is tied to a particular origin and spans all windows that are open on that domain. If you set some data on local storage it immediately becomes available on any other window on the same domain. It also remains available until it's explicitly deleted either by the web application or by the user. Otherwise, you can close your browser, reboot your machine, come back to it days later, and the data will still be there. Here you have persistent data without the hassle of cookies, which require you to reset the expiry again and again.

What makes Web Storage much, much better than cookies is not only the API but also the event system that comes with it. I'll talk about events toward the end of this section.

{{aside

# Watch out for Firefox cookie security

Firefox implements slightly different security around access to session and local storage: If cookies are disabled, accessing `sessionStorage` or `localStorage` will throw a security error. For this reason, your application should check whether it's able to set cookies before trying to access either of these two storage APIs.

```js
var cookiesEnabled = (function () { // the id is our test value
  var id = new Date().getTime();
  // generate a cookie to probe cookie access
  document.cookie = '__cookieprobe=' + id + ';path=/';
  // if the cookie has been set, then we're good
  return (document.cookie.indexOf(id) !== -1);
})();
```

This code tries to set a cookie and then immediately read it back again. If it fails to read the cookie, it means that security is blocking you from writing and therefore you can't access the `sessionStorage` or `localStorage`. If cookies aren't enabled, the implications are that reading from `sessionStorage` or `localStorage` will cause a security warning and break your script.

Alternatively, you could just check for Web Storage support with a try/catch and polyfill support (as explained in Chapter 12 and somewhat later in this chapter) using JavaScript.

}}

### The 15-second tutorial

I'm so confident that you'll understand how to use `localStorage` immediately that I've included code below, even before I've explained how it all works, and I'm certain you'll grok the basics of Web Storage straightaway!

```js
localStorage.superHero = "Remy";
localStorage.superVillain = "Bruce";
// some super hero fight occurs
delete localStorage.superVillain;
// the page is reload, browser restarted - we don't care -we're superheroes!
alert("The world's baddest badass is: " + localStorage.superHero);
```

Yep, it's that simple. If you shut down your browser, reboot your machine, and go back to the same domain where this data was set, it would all still be there. You could alert out the `localStorage.superHero` value and it would give you, of course, *Remy*!

### An overview of the API

Since both `sessionStorage` and `localStorage` descend from the Web Storage API, they have the exact same API (from the specification):

* `readonly attribute unsigned long length;`
* `getter DOMString key(in unsigned long index);`
* `getter DOMString getItem(in DOMString key);`
* `setter creator void setItem(in DOMString key, in any data); deleter void removeItem(in DOMString key);`
* `void clear();`

This API makes setting and getting data very easy. The `setItem` method simply takes a key and a value. The `getItem` method takes the key of the data you want and returns the content,

as shown here:

```js
sessionStorage.setItem('twitter', '@rem');
alert( sessionStorage.getItem('twitter') ); // shows @rem
```

It's worth making very clear that the `getItem` method only supports strings. This is important because it means if you try to store an object, it actually returns "[Object object]." More importantly, this means numbers being stored are actually being returned as strings, which can cause errors in development.

To highlight the possible problems, here's an example: Let's say that Bruce runs a website selling videos of himself parading as a professor of science. You've added a few of these videos to your shopping basket because you're keen to learn more about "synergies." The total cost of your shopping basket is $12, and this cost is stored in `sessionStorage`. When you come to the checkout page, Bruce has to add $5 in shipping costs. At an earlier point during your application, $12 was stored in `sessionStorage`. This is what your (contrived) code would look like:

```js
sessionStorage.setItem('cost', 12);
// once shipping is added, Bruce's site tells you thetotal cost:
function costWithShipping(shipping) {
alert(sessionStorage.getItem('cost') + shipping); }
// then it shows you the cost of the basket plus shipping: costWithShipping(5);
```

If `sessionStorage` had stored the value as a number, you would see an alert box showing 17. Instead, the cost of $12 was saved as a string. Because JavaScript uses the same method for concatenation as it does for addition (for example, the plus symbol), JavaScript sees this as appending a number to a string--so the alert box actually shows 125--much more than you'd probably be willing to pay to watch any video of Bruce! What's going on here is type coercion: upon storing the data in the storage API, the data type is coerced into a string.

Finally, it's worth noting that if the key doesn't exist when you call `getItem`, the storage API will return null. If you're planning to use the storage API to initialise values, which is quite possible, test for null before proceeding because it can throw a pretty nasty spanner in the works if you try to treat null as any other type of object.

### Ways to access storage

You're probably thinking, "Hang on a minute, Remy showed me how to grok web storage in 15 seconds, but how does all this `getItem`, `setItem` stuff relate?" I'm glad you're paying attention.

If you look back at the API, you'll see that `getItem`, `setItem`, and `removeItem` are a getter, setter, and deleter, respectively. This means that when we call delete `localStorage.superVillain`, JavaScript is making a call to `removeItem` for us. Of course, if you spotted that already, good for you. Pat yourself on the back.

An expando is a short and expressive way of getting, setting, and deleting data out of the storage object, and as both `sessionStorage` and `localStorage` descend from the Web Storage API, they both support this method of accessing the data.

Using our example of storing a Twitter screen name, we can do the same thing using expandos:

```js
sessionStorage.twitter = '@rem';
alert( sessionStorage.twitter ); // shows @rem
```

Remember the expando method of storing values is also subject to the "stringifying" of values as we saw in the previous example, with Bruce's video website, because it's going via the setter method of `setItem`.

#### Using the key method

The API also provides the key method, which takes an index parameter and returns the associated key. This method is useful to enumerate the data stored in the storage object. For example, if you wanted to show all the keys and associated data, you wouldn't particularly know what the keys were for each of the data items, so loop through the length of the storage object and use the key method to find out:

```js
for (var i = 0; i < sessionStorage.length; i++) {
  alert( sessionStorage.key(i) + '=' + sessionStorage.getItem( sessionStorage.key(i) ) );
}
```

Another word of warning: It's conceivable that you might be storing some value under the name of "key," so you might write some code like the following:

```js
sessionStorage.setItem('key', '27152949302e3bd0d681a6f0548912b9');
```

Now there's a value stored against the name "key," and we already had a method called key on the storage object. Alarm bells are ringing, right?

Some browsers, WebKit specifically, overwrite the key method with your new value. The knock-on effect is the developer tools in WebKit make use of the key method to enumerate and display all the data associated with the storage object--so the "Storage" view for that storage type (`sessionStorage`, in our example) will now be broken until that value has been removed.

Other browsers such as Firefox will keep the key method and your key value stored separately. Using the expando syntax will give you the method, and using `getItem('key')` will give you the value.

#### Removing data

There are three ways to remove data from the storage object programmatically: directly using the deleter, `removeItem`, and clear. The `removeItem` method takes a key, the same key used in `setItem` and `getItem`, and deletes the entry for that particular item.

Using clear removes all entries, clearing the entire storage object. For example

```js
sessionStorage.setItem('remy', "Master of the Universe");
sessionStorage.setItem('bruce', "Master of the Puniverse");
alert( sessionStorage.length ); // shows 2
sessionStorage.removeItem('bruce');
alert( sessionStorage.length ); // show 1
sessionStorage.clear();
alert( sessionStorage.length ); // shows 0
```

#### Storing more than strings

> JSON (JavaScript Object Notation) is a text based open standard for representing data. The specification found at[ http://json.org]( http://json.org) is so simple it actually fits on the back of a business card!

You can work around the stringifying of objects by making use of JSON. Since JSON uses text to represent a serialised JavaScript object, we can use this to store objects and convert stored data back into objects. However, it would require putting a wrapper on the set and get methods, which (depending on your application) may not be a problem at all.

All the latest browsers (either nightly or final releases) support native JSON encoding using the JSON.parse and JSON.stringify methods. For those browsers that don't have JSON support, we can include Douglas Crockford's JSON library (available on [github](https://github.com/douglascrockford/JSON-js)).

Now you can convert your data storage and retrieval with JSON as follows:

```js
var videoDetails = {
  author: 'bruce',
  description: 'how to leverage synergies',
  rating: '-2'
};

sessionStorage.setItem('videoDetails', JSON. stringify(videoDetails));

// later on, as in page reloads later, we can extract thestored data
var videoDetails = JSON.parse(sessionStorage.getItem('videoDetails'));
```

As I mentioned in the API overview section, if the key doesn't exist in the storage object, then it will return null. This isn't a problem for the native JSON parsers as `JSON.parse(null)` returns null--as you would expect. However, for Douglas Crockford's JavaScript version, passing null will throw an error. So if you know it's possible that Crockford's JSON JavaScript library is being loaded, protect against this error by using the following:

```js
var videoDetails = JSON.parse(sessionStorage.getItem('videoDetails') || 'null');
```

This ensures that if null is returned from the `getItem` method, you pass in a JSON-encoded version of null, and thus the JavaScript based JSON parser won't break.

#### Using debugging tools

Although there's good support for the Web Storage API, the debuggers are still maturing. So aside from inspecting the `sessionStorage` or the `localStorage` there are just a few tools available. Often from the debugging tools, you can modify keys and values and delete entries.

> To enable the Developer menu in Safari, go to Preferences and from the Advanced tab, check the Show Developer Menu in the Menu Bar box. Chrome's debugger is available from the "spanner," Tools menu, and Developer Tools.

##### Webkit's Developer Tools

While I refer to WebKit, in this section I'm covering Safari, the nightly build of Safari (WebKit) and Google Chrome. WebKit's developer tools allows us to view the `localStorage` and `sessionStorage` values stored as shown in Figure 6.1.

{{figure 6.1
Figure 6.1 Chrome's storage debugger (Safari has very nearly the same interface).
}}

##### Firefox's Debugger

Using Firefox's native JavaScript console you can easily inspect the storage objects. If you enter "`sessionStorage`" or "`localStorage`" in the console command and execute the code, the storage object can now be clicked on and its details can be seen (Figure 6.2).

{{figure 6.2
Figure 6.2 Firefox's built in debugger.
}}

##### Opera Dragonfly

Dragonfly comes shipped with Opera, and from the Storage tab you can access all the data stored in association with the current page. In particular, there are separate tabs for Local Storage and Session Storage to inspect all the data linked with those data stores (Figure 6.3).

{{figure 6.3
Figure 6.3 Opera Dragonfly debugger to inspect storage.
}}

### Storage Events

What makes Web Storage particularly unique is that it also comes with events that notify you of updates to the data store.

The first thing to know is that the storage event doesn't fire on the window storing the actual data. It will only fire on the other windows whose storage is affected.

This means that storage events only fire for `sessionStorage` on iframes on the same origin and windows that have been opened using the pop-up technique of window.open(), as these all share the same session. Storage events for `localStorage` fire on all windows open on the same origin, and we'll see an example of how that could be useful.

When the event fires, it also contains all the information about the data change as you can see from the storage event object below:

```js
StorageEvent {
  readonly DOMString key;
  readonly any oldValue;
  readonly any newValue;
  readonly DOMString url;
  readonly Storage storageArea;
};
```

Remember that although the specification says it supports "any" value, it doesn't. All the browsers (currently) coerce these values to strings, so you can be sure the `oldValue` and `newValue` will be strings!

The `storageArea` points to either `localStorage` or `sessionStorage`, obviously depending on where the data was stored.

#### Syncing windows using storage events

Let's say we're building a radio station's website and the station had a pop-up player for the radio--but this pop-up only shows me the current song and some controls. I'm able to select music from the main window the pop-up came from (or perhaps any other window that's on this radio website, as we'll see shortly). I'm sure you've used these before when you want to listen to live music, and it's a decent way to keep the player window open the whole time.

> If you're young and not British there's a good chance you've never heard of Smashie and Nicey--feel free to go looking for them on YouTube!

Now we return to the website, and whilst browsing, we decide that we'd rather listen to Katy Perry and put a swift end to the live radio stream from Smashie and Nicey. But herein lies the problem: We've hit Play in the main window, but the pop-up doesn't now reflect that we're listening to "I Kissed a Girl." Storage events will save this particular website.

We can also use the storage API to work out whether the popup player is open already and avoid playing an audio stream more than once. (You'd not want Katy Perry competing with Smashie and Nicey at the same time--heavens no.)

From our main website, we can use the following code to track the state of the pop-up and in the pop-up code (which will follow), we listen for the event to say a new song has been selected, and we update the display.

```js
function popupPlayer() {
  if (!localStorage.playerOpen) {
    // coerced to "true" but when it closes,
    // we'll remove the value.
    localStorage.playerOpen = true;
    // open popup
  }
}

function play(song) {
  localStorage.currentlyPlaying = song.title;
  // goes off and plays song in some quasi DRM, streaming way
}

function stop() {
  // when the song stops, or the user stops the song manually,
  // we want the popup player to update too
  localStorage.removeItem('currentPlaying');
}
```

Now in the pop-up, along with the code that plays the audio stream, we need to listen for the storage event that tells us the `currentPlaying` value has changed, and then we can start that funky new song:

```js
function handleStorage(event) {
  event = event || window.event; // support IE8
  if (event.newValue === null) { // it was removed
    stopPlaying(); } else {
    // start playing and update display
    startPlaying(event.newValue);
  }
}

window.addEventListener('storage', handleStorage, false);
window.attachEvent('storage', handleStorage);
```

Obviously there are more uses than radio, but the potential of storage events is the ability for completely separate windows on your domain to speak to each other, something that in the past would have been very fiddly indeed.

### Fallback options

As the storage API is relatively simple, it's possible to replicate its functionality using alternative JavaScript methods, which could be useful if the storage API is unavailable.

> If you want to find out about polyfills, head over to [Chapter 12](/chapter/12); we'll wait here until you're done.

For `localStorage`, you could use cookies, or for better support you could use the browser specific `userData` methods or even a Flash object. For `sessionStorage`, you can use a polyfill that makes use of the name property on the window object. The following listing shows how you could replicate most of `sessionStorage`'s functionality (and ensure the data remains locked to the current window, rather than leaking as cookies would) by manually implementing each of the Storage API methods. Note that the following code expects that you have JSON support in the browser, either natively or by loading Douglas Crockford's library.

```js
if (typeof sessionStorage === 'undefined') {
  sessionStorage = (function () {
    var data = window.top.name ? JSON.parse(window.top.name) : {};
    return {
      clear: function () {
        data = {};
        window.top.name = '';
      },
      getItem: function (key) {
        return data[key] || null;
      },
      key: function (i) {
        // not perfect, but works var ctr = 0;
        for (var k in data) {
          if (ctr == i) return k
          else ctr++;
        }
      },
      removeItem: function (key) {
        delete data[key];
        window.top.name = JSON.stringify(data);
      },
      setItem: function (key, value) {
        data[key] = value+''; // forces the value to a string
        window.top.name = JSON.stringify(data);
      }
    };
  })();
}
```

The problem with implementing `sessionStorage` manually (as shown in the previous code listing) is that we don't have the setters and getters (or rather IE7 and below doesn't support setters and getters and those are really the only widely deployed old browsers that lack native `sessionStorage`). This means you couldn't write `sessionStorage.twitter = '@rem'`. Although technically,thecode would work, it wouldn't be registered in our storage object properly and `sessionStorage.getItem('twitter')` wouldn't yield a result. You could get around that particular problem, but most importantly, refreshing the browser would lose the data.

With this in mind, and depending on what browsers you are targeting (that is, whether you would need to provide a manual fallback to storage), you may want to agree with yourself for safety as to when you should stick to using the `setItem` and `getItem` methods.

## Web SQL Database

Web SQL Database is another way to store and access data. As the name implies, this is a real database that you are able to query and join results. If you're familiar with SQL, then you should take like a duck to water with the database API. That said, if you're not familiar with SQL, and SQLite in particular, I'm not going to teach it in this chapter: There are bigger and uglier books that can do that, and the SQLite website (http://sqlite.org) is a good starting point.

The specification is a little bit grey around the size limits of these databases. When you create a new database, you, the author, get to suggest its estimated maximum size. So you could estimate 2 MB or you could estimate 20 MB. If you try to create a database larger than the default storage size in Safari, it prompts the user to allow the database to go over the default database size. Both Opera and Chrome simply allow the database to be created, regardless of the size. I strongly suggest that you err on the side of caution with database sizes; as I said earlier, browsers limit databases to 5 MB per domain by default. Now that you're suitably worried about SQL and database sizes, one really neat feature of the Web SQL Database API is that all the methods allow you to pass a callback that will be executed once the fandango SQL magic has completed. Callbacks are a common trait of JavaScript libraries such as jQuery. If you're not familiar with this syntax, it looks something like this (but don't worry, I'll hold your hand throughout the examples later on):

```js
transaction.executeSql(sql, [], function () {
  // my executed code lives here
});
```

Due to the nature of the callback system, it also means that the database API is asynchronous, so you need to be careful when authoring the JavaScript to deal with the database to ensure that the sequence of events runs correctly. However, the SQL statements are queued and run in order in which they were queued, so this is one slight advantage you have over processing order: you can create tables and know that the table will be in place before you run queries on the tables.

Put plainly, if you want your code to run after the database interaction has completed, use the callback. If you don't need to wait, and you want your code to continue regardless, continue after the database API call.

{{aside

# Be wary of versioning!

The implementations of Web SQL Database support a slightly older version of the Web SQL Database API, and more specifically the versioning model.

Although the specification describes how you can manage and migrate from different versions of the database, this hasn't been implemented very well. The model requires you to know the version of the database on the user's machine to be able to open it. The problem is that if you have migrated through multiple versions of your database, there's no way to determine which version the visiting user is on, and opening the database with the wrong version number throws an `INVALID_STATE_ERROR`. You could wrap each of the open database attempts in a try/catch, but you'd require one for each version of your database, something that could get very messy after a few years of upgrades.

}}

### Using the Web SQL Database API

The typical database API usage involves opening the database and then executing some SQL. Note that if I were working with a database on the server side, I would typically close the database connection. This isn't required with the database API, and in fact there's no way to do this. That said, you can open a database multiple times without any adverse effect.

#### Opening and creating databases

By opening a database for the first time, the database is created. You can have only one version of your named database on the domain at any one time, so if you create version 1.0 you can't then open 1.1 without the database version having been specifically changed by your application. For the rest of this chapter, I'm going to ignore versioning and stick to one version only due to the previously stated warning.

```js
var db = openDatabase('mydb', '1.0', 'My first database', 2 * 1024 * 1024);
```

The latest version of the SQL databases spec includes a fifth argument to `openDatabase`, but this isn't supported in any of the browsers right now. It offers a callback when the database is created for the first time. You've now created a new database called "mydb," version 1.0, with a text description of "My first database," and you've set the size of the data to 2 MB (this has to be set in bytes which is why I multiply 2 * 1024 * 1024). To ensure that the app works and detects support for the Web SQL Database API, you should also test for database support in the browser, so wrap the code with the `openDatabase` test:

```js
var db;
if (window.openDatabase) {
  db = openDatabase('mydb', '1.0', 'My first database', 2 * 1024 * 1024);
}
```

It's as simple as that. Next you need to set up a new table in the database, which--like all other operations we'll be doing on this database--is done through the `executeSql` method.

#### Creating tables

When creating tables (or performing any other action on the database), you must start a database "transaction" and, within the callback, execute the relevant SQL. The transaction callback receives an argument containing the transaction object, which allows you to run SQL statements and run the `executeSql` method (tx in the following example). This is done using the database object that was returned from `openDatabase` and by calling the transaction method:

```js
var db;
if (window.openDatabase) {
  db = openDatabase('tweetdb', '1.0', 'All my tweets',2 * 1024 * 1024);
  db.transaction(function (tx) {
    tx.executeSql('CREATE TABLE tweets (id, date, tweet)');
  });
}
```

The `executeSql` method takes four arguments, of which only the first is required:

1. SQL

2. Arguments to SQL (such as field values)

3. Success callback

4. Error callback

In the previous example, you use only the SQL parameter. Of course, if the statement to create a table runs and the table already exists, an error is triggered, but since you're not catching it and it doesn't affect the program flow, in this instance you don't care.

However, the next step of this application is to load the database with tweets from Twitter, and as this has to happen once the table is in place (because of the asynchronous nature of the Web SQL Database API), you'll have to get the tweets in the "success" callback. Here's where we run into a problem:

If the table exists, the transaction will fail and won't trigger the success callback. The code will run fine the first time around, but not the second. So to get around this, you'll say to create the table only if the table doesn't exist; this way the success callback fires if the table is created and if the table already exists, and the error callback is only called if there's some other problem.

```js
var db;
if (window.openDatabase) {
  db = openDatabase('tweetdb', '1.0', 'All my tweets',2 * 1024 * 1024);
  db.transaction(function (tx) {
    tx.executeSql('CREATE TABLE IF NOT EXISTS tweets(id, date, tweet)', [], function () {
      // now go and load the table up with tweets
    });
  });
}
```

#### Inserting and querying

Now let's say you hit Twitter for a search query for all the mentions of HTML5, you store all those tweets in your database, and then you allow the user to select the time range of tweets from the past 5 minutes, 30 minutes, 2 hours, and then all time. The time range selection will be radio buttons with click handlers, and you'll run your query to show only the tweets from that time range.

The crux of this application is split between storing the tweets in your database and showing the tweets depending on the time range.

Before any of your code runs, you must first create the database and tweets table, which will include a date column whose type is integer--which is important, as it will allow you to query the database later on in your application:

```js
function setupDatabase() {
  db = openDatabase('tweets', '1.0', 'db of tweets',2 * 1024 * 1024);
  db.transaction(function (tx) {
    tx.executeSql('CREATE TABLE tweets (id unique, screen_name, date integer, text)');
  });
  getTweets();
}
```

A few things to note about the code are:

1. I'm using a global db variable. (I'm just using a global for the contrived example; global is generally bad in JavaScript.)

2. I'm telling the tweets database that the id column is unique. This means if there's a duplicate INSERT attempt, the INSERT fails.

3. If the CREATE TABLE fails, it's fine because it will fail only when the table already exists, and you're not doing anything else in that transaction.

4. Once it's done, I call `getTweets`, which will make the API request to Twitter, which will in turn call the storing function.

What if `getTweets` runs before the table gets created? It doesn't matter. That's because when we get the tweets, a new transaction is created that inserts the new SQL. Since transactions run in the order they were sent to the database, even if the create table hasn't actually run when we're creating transactions to insert new rows, we know that it's queued ahead of the new rows and will be there all in good time.

> You're creating a new transaction for each stored tweet. I'll explain transactions in more detail in the next section, but by wrapping individual `INSERT` statements you're ensuring that all the new tweets are stored, irrespective of whether you already have these in the database.

The `forEach` in the following code is a new JavaScript method available in all the latest browsers, allowing you to loop through an array. Mozilla's site provides simple code for implementing this in browsers that don't have it natively: [Array.forEach](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/forEach). Once the Twitter API call completes, it will call `saveTweets`, which will store each of the tweets:

```js
function saveTweets(tweets) {
  tweets.results.forEach(function (tweet) {
    db.transaction(function (tx) {
      var time = (new Date(Date.parse(tweet.created_at))).getTime();
      tx.executeSql('INSERT INTO tweets (id, screen_name,date, text) VALUES (?, ?, ?, ?)', [tweet.id,tweet.from_user, time / 1000, tweet.text]);
      // div 1000 to get to seconds
    });
  });
}
```

The INSERT statement is the most important part, and now you can see how the field arguments work:

```js
tx.executeSql('INSERT INTO tweets (id, screen_name, date,text) VALUES (?, ?, ?, ?)', [tweet.id, tweet.from_user,time / 1000, tweet.text]);
```

Each "?" in the INSERT statement maps to an item in the array that is passed in as the second parameter to `executeSql`. So the first "?" maps to tweet.id, the second to tweet.from_user, and so on.

You can also see that I've divided the time by 1,000; this is because JavaScript time is counted in milliseconds, whereas SQLite wants it to be in whole seconds. This is only important for your query later on in the code where you show tweets that are 5 minutes old. This matters because you're storing dates as integers, and one second using JavaScript's `getTime` method gives us 1,000, whereas one second using SQLite gives us 1. So you divide by 1,000 to store seconds rather than milliseconds.

Finally, when the radio buttons are clicked, you call the show function with the amount of time as the argument:

```js
var tweetEl = document.getElementById('tweets');

function show(amount) {
  db.transaction(function (tx) {
    tx.executeSql('SELECT * FROM tweets' + (amount !='all' ? ' WHERE date > strftime("%s", "now", "-' +amount + ' minutes")' : ''), [], function (tx, results) {
      var html = [],
          len = results.rows.length;

      for (var i = 0; i < len; i++) {
        html.push('<li>' + results.rows.item(i).text +
'</li>');
      }
      tweetEl.innerHTML = html.join('');
    });
  });
}
```

This code may initially look complicated, but there are actually only a couple of things happening here:

1. Start a new transaction.

2. Run a single SQL statement, whose structure is determined by whether you want "all" or not.

Loop through the results constructing the HTML, and then set it to the `tweetEl` (a `<ul>` element) `innerHTML`. There are two states the SQL query can be:

```sql
SELECT * FROM tweets
```

or

```sql
SELECT * FROM tweets WHERE date > strftime("%s", "now", "-5 minutes")
```

Where I've put -5 minutes, this can change to -30 minutes or any number that's passed in to the show function. The strftime SQLite function is generating the number of seconds from 1-Jan-1970 until "now" minus N minutes. Since the "date" field is being stored as an integer, you can now grab all the rows that were tweeted within the last N minutes.

Now you've used the third argument to the `executeSql` method, the success callback. The success callback receives a transaction object (just as the transaction callback does, so you could run another `executeSql` if you wanted), and more importantly, the result set. The result set contains three attributes:

- `insertId` (set only if you've inserted one or more rows)--I didn't use this in this example.
- `rowsAffected`--Since this is a `SELECT` statement, this value is 0.
- `rows`--This isn't an array, it's a collection, that does contain a length and item getter method. You make use of the rows object, and run a for loop from 0 to the length of the rows, and use `results.rows.item(i)` to get the individual rows. The individual row is an object representing the different column names, so `results.rows.item(0)`.`screen_name` gives us the screen_name field from the first row.

Finally, once you have looped through all the rows that match, you can set a `<ul>` element to the HTML you've built up. In this example, the `<ul>` is stored in the variable called `tweetEl`.

Finally, once you have looped through all the rows that match, you can set a `<ul>` element to the HTML you've built up. In this example, the `<ul>` is stored in the variable called `tweetEl`.

Here is the complete code including the database support detection and the click handler code for the radio buttons:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset=utf-8 />
    <title>HTML5 tweet time range</title>
    <style>
      body { font-family: helvetica, arial;}
    </style>
  </head>
  <body>
    <form>
      <fieldset>
        <legend>Select a time range of recent HTML5 tweets</legend>
      <input type="radio" value="5" id="t5m" name="timerange"/>
      <label for="t5m">5 minutes</label>
      <input type="radio" value="30" id="t30m" name="timerange" />
      <label for="t30m">30 minutes</label>
      <input type="radio" value="120" id="t2h" name="timerange" />
      <label for="t2h">2 hours</label>
      <input type="radio" value="all" id="tall" name="timerange" checked="checked" />
      <label for="tall">all time</label>
    </fieldset>
    </form>

    <ul id="tweets"></ul>

    <script>
    var tweetEl = document.getElementById('tweets');
    var db;

    function setupDatabase() {
      if (!window.openDatabase) {
        tweetEl.innerHTML = '<li>Web SQL Database API is notavailable in this browser, please try nightly Opera,Webkit or Chrome.</li>';
        return;
      }
      db = openDatabase('tweets', '1.0', 'db of tweets',2 * 1024 * 1024);
      db.transaction(function (tx) {
        tx.executeSql('CREATE TABLE tweets (id unique,screen_name, date integer, text)');
      });
      getTweets();
    }

    function getTweets() {
      var script = document.createElement('script');
      script.src = 'http://search.twitter.com/search.json?q=html5-RT&rpp=100&callback=saveTweets';
      document.body.appendChild(script);
    }

    // our Twitter API callback function
    function saveTweets(tweets) {
      tweets.results.forEach(function (tweet) {
        db.transaction(function (tx) {
          var time = (new Date(Date.parse(tweet.created_at))).getTime();
          tx.executeSql('INSERT INTO tweets (id, screen_name,date, text) VALUES (?, ?, ?, ?)', [tweet.id,tweet.from_user, time / 1000, tweet.text]);
          // divide by 1000 to get to seconds
        });
      });
    }

    function show(amount) {
      db.transaction(function (tx) {
        tx.executeSql('SELECT * FROM tweets' + (amount !='all' ? ' WHERE date > strftime("%s", "now", "-' +amount + ' minutes")' : ''), [], function (tx, results) {
          var html = [],
              len = results.rows.length;

          for (var i = 0; i < len; i++) {
            html.push('<li>' + results.rows.item(i).text + '</li>');
          }

          tweetEl.innerHTML = html.join('');
        });
      });
    }

    // bind the click handlers for the radio buttons
    [].forEach.call(document.querySelectorAll('input[type=radio]'), function (el) {
      el.onclick = function () {
        show(this.value);
      };
    });

    // go!
    setupDatabase();
    </script>
  </body>
</html>
```

#### Creating transactions-- and what they're good for

I've skipped over transactions so far. They're more than meets the eye. They're not just the way to run queries; they serve a particularly useful purpose. Transactions are like closed environments in which you can run your queries. You can run just one query or a group of queries within a transaction. In fact, you *can't* run a query *without* being inside a transaction, since the `executeSql` method is *only* available from the `SQLTransaction` object.

Possibly the most important aspect of transactions is this: If something fails inside the transaction (vanilla code or SQL statements), then the whole transaction (including any insertion, modifications, or deletions) is rolled back. This means it's as if the whole transaction block of code never happened.

The transaction method takes two arguments. The first is the content of the transaction; the second, optional, is the error handler. Below is a contrived example that shows how a failed transaction gets rolled back:

```js
var db = openDatabase('foo', '1.0', 'foo', 1024);
db.transaction(function (tx) {
  tx.executeSql('CREATE TABLE foo (id unique, text)');
  tx.executeSql('INSERT INTO foo (id, text) VALUES (1, "foobar")');
});

db.transaction(function (tx) {
  tx.executeSql('DROP TABLE foo');
  // known to fail - so should rollback the DROP statement
  tx.executeSql('INSERT INTO foo (id, text) VALUES (1, "foobar")');
}, function (error) {
  // error.message is "no such table: foo"
  alert('Rollback triggered, the table "foo" was never dropped due to: ' + error.message);
});

db.transaction(function (tx) {
  tx.executeSql('SELECT * FROM foo', [], function (tx,results) {
    alert('found ' + results.rows.length + ' row');
  }, function (tx, error) {
    // this will never execute
    alert('something went wrong: ' + error.message);
  });
});
```

The steps in the previous code are:

1. Start a transaction that creates the table foo and then inserts a single row.

2. Start a transaction that drops the table foo and then incorrectly tries to insert a new row in foo.

3. The transaction fails, and rolls back the statements (that is, it's as if Step 2 never happened).

4. Start a transaction that selects all the rows from foo and alerts the number of rows.

5. The SQL query succeeds and shows "found 1 row."

Transactions are used to ensure that an atomic block of queries executes and that if any part fails, it rolls back.

## IndexedDB

IndexedDB was being talked about when the first edition of this book was published, but there were no implementations at the time. Today there are only vendor-prefixed implementations at this point, but I suspect it won't be long before most, if not all, browsers support IndexedDB.

IndexedDB is a document object store. It's like a database, but it doesn't come with all SQL and relational database gubbins.

In IndexedDB, you create a new database and give it a name and a version so you can reopen it later. Then you create an object store, which is very much like a filing cabinet with indices that allow you to quickly skim through and find the right document. Once the store is ready, you can store any kind of object against the index you're filing with. It doesn't matter what it contains, and it doesn't have to have the same properties as the other objects either. This is where SQL often becomes a problem. You have a huge table, you need to add one teeny, inconspicuous new column, and so begins the pain. You have none of those woes with IndexedDB.

{{aside

# Using IndexedDB before it's out of beta

IndexedDB may still be in the vendor-prefix stage by the time you read this chapter.

If that's the case, you can still use IndexedDB, but you will need to either create forks in your code to han-

dle the different naming convention, or just copy the vendor-prefixed version into the real name:

```js
function importIndexedDB(prefix) {
  var indexedDB = window[prefix + 'IndexedDB'],
  IDBTransaction = window[prefix + 'IDBTransaction'];
  if (indexedDB !== undefined) {
    window.indexedDB = indexedDB;
  }

  if (IDBTransaction !== undefined) {
    window.IDBTransaction = IDBTransaction;
  }
}

// try all the vendor prefixes
'moz webkit o ms'.split(' ').forEach(function (vendor) {
  importIndexedDB(vendor);
});
```

}}

## Creating new IndexedDBs

To kick things off you need to open a new indexed database. You'll use the return value to create object stores and handle any errors, similar to Web SQL Database where you receive a database object and then open the database.

However, with IndexedDB every process is a request. As with Web SQL Database, all communication is asynchronous. It's common to see the return value called request, so that's what we'll use:

```js
var request = indexedDB.open('videos');
request.onerror = function () {
  console.log('failed to open indexedDB');
};

request.onsuccess = function (event) {
  // handle version control
  // then create a new object store
};
```

Now that the database is open, assuming there wasn't an error, the onsuccess event will fire. Before we can create the new object store we need to begin by doing two things:

- Store the actual database handle, so we can perform transactions to get and store data.
- Set the version on the database; if there's no version, it means the database has just been created for the first time (and a version will need to be set as we'll see in the following examples).

The success event handler passes along an event object much like the event object you'd receive if you were listening for a click event. Inside this event we find a property called target, and inside of that is the result. The result contains--as I hope you've guessed--the result of the particular function call. In this specific case, the `event.target.result` contains the open database handle to our "video" database.

So the onsuccess handler is updated as such:

```js
var db = null;

request.onsuccess = function (event) {
  // cache a copy of the database handle for the future db = event.target.result;
  // handle version control
  // then create a new object store
};
request.onerror = function (event) {
  alert('Something failed: ' + event.target.message);
};
```

Notice the error handler. In IndexedDB, errors bubble up from the request up to transaction and up to the database itself. This means that if an error occurs at any point during any kind of request, you'll see this alert box. But remember: Alert boxes are ugly and are not friends with the browser--particularly when in production; they make the salesmen angry. Make sure you change the alert box to something like a beautiful, roundedcorners message that gracefully handles the error. Now, on to initialising the database.

### Version control

The first thing we do once we've opened the database connection is to handle version control. You can use any string as your version number, but if you use some logic in how you increment your versions it might save you a bit of trouble in the future. Let's call this application version "0.1." If we make an upgrade, we can compare "0.1" (the string), which will be the database version, against "0.2" which would be our upgraded code. Since this is the first time any of our code has run, and therefore we've even tried to open a new database, let's check the version and if it doesn't match, set the version and create the object stores.

I should add that this isn't version control like something like SVN or Git--if you want to change the number of object stores in the database, you need to request a version change.

```js
var db = null, version = '0.1';
request.onsuccess = function (event) {
  // cache a copy of the database handle for the future db = event.target.result;
  // handle version control
  if (version != db.version) {
    // set the version to 0.1
    var verRequest = db.setVersion(version);
    verRequest.onsuccess = function (event) {
      // now we're ready to create the object store!
    };
    verRequest.onerror = function () {
      console.log('unable to set the version :(');
    };
  }
};
```

Once the success event fires we can create our new object stores using the `setVersion` method.

### Creating object stores

Inside the version control success event handler, create new object stores as follows:

```js
var verRequest = db.setVersion(version);
verRequest.onsuccess = function (event) {
  var store = db.createObjectStore('blockbusters', {
    keyPath: 'title',
    autoIncrement: false
  });
  // at this point we would notify our code
  // that the object store is ready
};
```

For this application we've created a single object store, but in our next version we might choose to add an object store for directors of the movies in our video database. What's important in the `createObjectStore` method is the options argument we passed. This tells the object store that there should be an index (used to retrieve the blockbuster movie) and that its ID should not automatically increment; in fact, the `autoIncrement` flag is false by default; I've included it simply to show you how it could be used.

When it comes to storing new objects now, I must ensure the video has a unique title property, which will be indexed by IndexedDB for fast retrieval later.

Perhaps we're going to store the director name in the blockbuster video data, and not in a separate object store. In addition, I want to be able to search by director, so we add another index to our datastore:

```js
store.createIndex('director', 'director', { unique: false });
```

With this we have now given the index a name (the first argument), and then the name of the property (in our case, 'director') we want indexed when new objects are stored. Finally, we'll allow more than one film by the same director by indicating that we don't expect the values to be unique.

This all means I can store and easily retrieve a blockbuster entry looking like this:

```js
{
  title: "Belly Dance Bruce - Final Strike", date: (new Date).getTime(), // released TODAY! director: "Bruce Awesome",
  length: 169, // in minutes
  rating: 10,
  cover: "/images/wobble.jpg"
}
```

So let's add some videos to our blockbuster collection.

### Adding and putting objects in stores

Okay, "adding and putting." No doubt you're thinking: ambiguous! There are two methods for inserting data: add and put. The first adds new data and requires that the data not exist in the first place. The second puts an updated object in the store, and if the object isn't already stored, it will insert it as new.

For the purpose of our video store database, we're going to throw caution to the wind, and just use put. If you're not feeling as callous as I am, and there's a risk of duplicate objects (if, say, the title was the same but another field was different, it would leave us with two objects when we're only expecting one for each title), be sure you use add and put with appropriate validation and checks.

```js
var video = {
      title: "Belly Dance Bruce - Final Strike", date: (new Date).getTime(),
      director: "Bruce Awesome",
      length: 169,
      rating: 10,
      cover: "/images/wobble.jpg"
    },
    READ_WRITE = IDBTransaction.READ_WRITE;

var transaction = db.transaction(['blockbusters'],READ_WRITE),
    store = transaction.objectStore('blockbusters'),
    request = store.put(video);
```

This code is actually doing quite a lot on the last three lines, and if you're like me, you might think there's some unnecessary repetition.

We're performing three separate tasks, outlined below.

#### 1. Create the transaction

```js
transaction = db.transaction(['blockbusters'], READ_WRITE)
```

The first task is to create a new transaction with read and write permission to the named object stores. A transaction can be bound to more than one object store, which is why we're passing in an array here. In practice I've found that I could pass null or even an empty string in the object store name argument. I'm not sure that's valid, or if it should really work, but like I said: IndexedDB is new and still in vendor-prefix mode, so it's best to stick to what the spec suggests.

Also, if we were just planning to execute read operations in the transaction, we could use `IDBTransaction.READ_ONLY`.

{{aside

#A day in the short life of a transaction

Transaction objects have a very short lifetime linked to the event loop in a browser. If you create a transaction and don't use it and return to the event loop, the transaction will be dead and unusable.

If, however, you run the request immediately, and if the request is successful, you can choose to place a subsequent request on the transaction and be safe in the knowledge that it will still be alive. You can continue to do this so long as you don't break for the event loop.

If you've ever used a `setTimeout(fn, 0)` in your code, you've released to the event loop--maybe to allow the browser to repaint the page, maybe for something else.

This is a fairly unique concept that I've not seen before, so definitely experiment with the transaction lifetime. Once you've got a good handle on when it's alive and when it's dead, you'll be able to make the transaction last longer than a zombie.

}}

#### 2. Get a reference to the store

```js
store = transaction.objectStore('blockbusters')
```

This is where we get a hard fix on the object store we want to work with, and here we have to name the store. This could be any of the stores we listed in our transaction. Now, with our reference to the store, we can perform our actions, like add, put, and even get, which we'll see in a moment.

#### 3. Save the data

```js
request = store.put(video)
```

The request variable will receive a success or error event on the object. Maybe I care whether it's been stored, maybe I want my code to continue and let the spotty 15-year-old clerk continue adding the pile of Bruce Awesome videos to our database. That's the nice thing about the asynchronous-ness of IndexedDB--I can let my website carry on without being interrupted as the data is stored.

Now that you've stored some data, what about getting it out?

### Whipping it out again

If you've followed the process for storing data, the process of getting data back out is very similar and simple.

We still need to create a transaction. Since we're only getting data, we could ask for that transaction to be read-only, but it doesn't matter in this case if we use a read/write permission. We still get the object store, and instead of adding or putting, we get:

```js
var transaction = db.transaction(['blockbusters'],READ_WRITE),
    store = transaction.objectStore('blockbusters'),
    request = store.get(key);
```

The important part is that the key variable we pass to the get method is compared against the `keyPath` we defined when the object store was created. In our video example, we said that blockbusters have their key based on the video title.

What if you wanted to get all the videos out of the store? Using the get method won't cut it. We need to iterate through the entire data store:

```js
var transaction = db.transaction(['blockbusters'],READ_WRITE),
    store = transaction.objectStore('blockbusters'),
    data = [];

var request = store.openCursor();
request.onsuccess = function (event) {
  var cursor = event.target.result;
  if (cursor) {
    // value is the stored object
    data.push(cursor.value);
    // get the next object
    cursor.continue();
  } else {
    // we've got all the data now, call
    // a success callback and pass the
    // data object in.
  }
};
```

In this code block, we're opening up our object store as usual, but instead of executing a get we open a cursor. This allows us to cycle through each stored object. We could easily use this process to find all the videos with a rating of five or more stars by adding a nested check against cusor.value.rating before pushing the current stored object onto our data array of results.

For example:

```js
function find(filter, callback) {
  // READ_WRITE was declared earlier on in our code
  var transaction = db.transaction(['blockbusters'], READ_WRITE),
      store = transaction.objectStore('blockbusters'),
      data = [];

  var request = store.openCursor();
  request.onsuccess = function (event) {
    var cursor = event.target.result;
    if (cursor) {
      if (filter(cursor.value) === true) {
        // value is the stored object
        data.push(cursor.value);
      }
      // get the next object
      cursor.continue();
    } else {
      callback(data);
    }
  };
}

// example usage
find(function (data) {
  return data.rating > 5;
}, function (found) {
  alert('Found ' + found.length + ' videos with a high rating');
});
```

### Deleting and dropping data like a hot potato

What if you made a mistake or want to remove data? Maybe you've had complaints about Bruce's latest film, Banana Smash, Pink Fury, and you need to delete it.

The process is exactly the same as the get method, except we call the delete method when passing in the key (note that for this, you'll need write permissions too):

```js
var transaction = db.transaction(['blockbusters'],READ_WRITE),
    store = transaction.objectStore('blockbusters'),
    request = store.delete(key);
```

There's also a method for clearing an entire object store: `clear`. The `clear` method doesn't take any arguments and the process, again, is exactly the same.

There are two more ways of clearing data: `deleteObjectStore` and `deleteDatabase`. The method names are fairly self-explanatory, but they're not as simple to use.

`deleteObjectStore` can only run from a transaction. The method sits on the database object (the result of the indexedDB.open method). However, you can't delete the object store using a regular transaction. You can only delete the object store from a set version transaction. Remember earlier on in this section, when I showed you how to create object stores--the `setVersion` success handler is the only time you can both add and remove stores.

Finally, there's `deleteDatabase`. As handy as this would be for debugging, unfortunately it doesn't appear to be implemented in any browsers right now. I expect this will change as the specification matures and isn't vendor-prefixed, but for the time being it does make debugging difficult because it's hard to get back to the reset position.

{{aside

# Deleting an IndexedDB database in Chrome

There are probably ways of doing this in each browser, but I've discovered a way of removing the database, if you're happy poking around in Chrome.

Navigate to ~/Library/Application Support/Google/Chrome/Default/IndexedDB on a Mac and C:\Users\<you>\AppData\Local\Google\Chrome\User Data\Default\IndexedDB\ on Windows 7 (other system paths can be located at[ http://goo.gl/v702q]( http://goo.gl/v702q)).

Once you're in the IndexedDB directory, you can see databases listed by their domain. If you want to clear that database, make sure Chrome is closed, and just delete that file.

Do so at your own risk though--don't come running to me when your browser blows up all over your machine. That said, it's worked just fine for me so far!

}}

### Debugging

Debugging is hard. At the time of writing there are two key components missing from IndexedDB:

- There are no debugging tools. Web SQL Database and Web Storage both have visual tools in the browser web inspectors (like ChromeDevTools or Opera Dragonfly). There are currently none for IndexedDB, making it quite difficult to debug. It's not impossible--just tricky!
- There's no way to delete a database. As only Firefox and Chrome have IndexedDB at this time, and both still have vendor prefixes, I suspect this is only something that needs to be added. Since a necessary step during development is to reset the current state of the application, not being able to delete the database is fairly limiting. You can get around this by manually deleting all the object stores and then resetting the version, but it's really not the same!

However, it's still early days, and as a developer, the simplicity of working with IndexedDB has a much nicer feeling than Web SQL Database--or certainly for this developer it does.

## Summary

In this chapter, you learned about three different APIs for storing data locally in the browser that beat the pants off using cookies.

These storage APIs allow you to store a lot more data than the traditional cookie and make the associated programming a lot easier than before. On top of that, the Web Storage API has really good support in all the latest browsers (and older browsers can be supported using JavaScript).

In this humble author's opinion, although Web SQL Database is depreciated, it'll be here for some time--mostly because web giant's like Google use this technology in Gmail and they make browsers.

However, IndexedDB is very close to stable implementations and support could well overthrow Web SQL Database altogether. That said, if there's a limit of only 5 MB in IndexedDB and there's no way to increase that--Web Storage has 5 MB too, and it's dirt easy to develop with.

Whichever API you choose, it means you can drop the awful and stale cookies of today!