# Canvas

If the video element is the poster boy of HTML5, the canvas element is definitely the Han Solo of HTML5. It's one of the larger parts of the HTML5 specification, and in fact the canvas API, the 2D drawing context, has been split into a separate document, though the canvas element itself is still part of the official HTML5 spec.

The canvas element provides an API for two-dimensional drawing--lines, fills, images, text, and so on. The API has already been used in a huge range of situations, including (interactive) backgrounds to websites, navigation elements, graphing tools, full-fledged applications, games, and emulators. Who knew Super Mario canvas-based games would open the eyes of so many developers!

If you think back to the days of the version of MS Paint that came with Windows 95, you can imagine some of the functionality of canvas. In fact, Paint has been replicated using the canvas element, as shown in Figure 5.1. Applications that aim to become full-fledged vector drawing suites (Figure 5.2) are popping up all over the Web (whereas Scalable Vector Graphics [SVG] would be a better choice--see the "When to use Canvas, when to use SVG" sidebar later in this chapter). As these applications are based on Open Web technology, they work in a browser on more devices, too. The Harmony application shown in Figure 5.3 even works on mobile devices, including the iPhone and Android phones.

The 2D API is large enough that I suspect we'll see entire books dedicated to the subject. Since I have only one chapter to talk about it, I'll primarily show you the basics. But I'll also include some of the funky stuff you can do with the canvas element, like capturing frames from a video or processing individual pixels from an image inside the canvas. I'll even show you how to export to files ready to be saved to your desktop. And I'll show you how to create your first animation, which might even hark back to the days of BASIC computing.

{{figure 5.1

  Figure 5.1 MS Paint replicated using the canvas element.

}}

{{figure 5.2

  Figure 5.2 More advanced drawing applications are emerging using canvas.

}}

{{figure 5.3

  Figure 5.3 The canvas drawing demo Harmony also works, unmodified, on mobile browsers.

}}

## Canvas basics

The hello world of any canvas demo starts with putting the canvas element on your page. Initially the canvas is completely invisible and by default it is 300 pixels wide by 150 pixels high:

```html
<!DOCTYPE html>
<title>canvas hello world</title>
<canvas></canvas>
```

The canvas element is now in place. Use JavaScript to get the 2D context to allow you to draw:

```js
var ctx = document.querySelector('canvas').getContext('2d');
```

Now that you have the context, you have access to the full API to draw as you please. For instance, you can add simple shapes to your canvas (Figure 5.4):

{{figure 5.4

  Figure 5.6 A filled rectangle using the default settings on a canvas.

}}


```js
ctx.fillRect(10, 20, 50, 50);
```

{{aside

# What about browser support?

Browser support is fairly good for the canvas element; four of the big five browsers support canvas in the latest versions of the browser (and in fact its support is fairly good in previous versions of the browsers, too). "What about Internet Explorer?" is the question that is perpetually asked.

For versions of IE that don't support canvas (IE8 and below), you can shim canvas support in a few ways. The first is [FlashCanvas](http://flashcanvas.net) which looks to be the most promising. It does have to rely on Flash as the backup, but it should read all the canvas code and translate it for you to a Flash graphics layer.

Similarly, there is a method using Silverlight and a library called [html5canvas](http://blogs.msdn.com/delay/archive/2009/08/24/using-one-platform-to-build-another-html-5-s-canvas-tag-implemented-usingsilverlight.aspx); and finally there is a library called [excanvas](http://code.google.com/p/explorercanvas/), which translates the canvas API to Microsoft's VML.

These libraries don't cover the entirety of the 2D API, but they do cover most of the commonly used methods. Several demos show comparisons from examples in the wild. Out of these options, the web community appears pretty positive about the FlashCanvas polyfill. It's just a little ironic to me that we're relying on Flash (again) for a technology that's touted as replacing Flash. But, hey, this is the way of the web.

It's worth pointing out and being wary that these polyfills won't have the same performance as native canvas. Without seeing charts upon charts upon charts, I would expect the FlashCanvas to perform the best of the lot, but it won't be a like for like performance, particularly compared to when the browser has hardware-accellerated canvas rendering as IE9 does.

}}

The arguments to `fillRect` are x, y, width, and height. The x and y coordinates start in the top left. As shown in Figure 5.4, the default colour is black. Let's add some colour and draw an outline around the canvas so that the canvas looks like Figure 5.5:

{{figure 5.5

  Figure 5.5 Using fill styles and rectangle strokes.

}}

```
ctx.fillStyle = 'rgb(0, 255, 0)';
ctx.fillRect(10, 20, 50, 50); // creates a solid square
ctx.strokeStyle = 'rgb(0, 182, 0)';
ctx.lineWidth = 5;
ctx.strokeRect(9, 19, 52, 52); // draws an outline
```

In the previous code listing, you're drawing twice on the canvas: once with `fillRect` and once with `strokeRect`. When you're not drawing, you're setting the colour and style of the 2D context which must happen before the fill or stroke happens, otherwise the default colour of black is used. Along with CSS colours (for example, RGB, hex, RGBA, and so on), `fillStyle` and `strokeStyle` also accept gradients and patterns generated using the 2D API.

## Painting gradients and patterns

> `querySelector` and `querySelectorAll` are new DOM methods that accept a CSS selector and return the elements it matches. Currently available in all the latest browsers, `querySelector` returns the first DOM node it finds, whereas `querySelectorAll` returns a `NodeList` object that you'll need to iterate over.

Using the context object, you can generate a linear gradient, radial gradient, or a pattern fill, which in turn can be used as the `fillStyle` on the canvas. Gradients and radial gradients work similar to CSS gradients, in that you specify a start point and colour stops for the gradient.

Patterns, on the other hand, allow you to point to an image source and then specify how the pattern should repeat, again similar to the repeat process on a CSS background image. What makes `createPattern` really interesting is that the image source can be an image, another canvas, or a video element (though using video as a source isn't yet implemented at the time of writing).

Creating a simple gradient is easy and possibly even faster than starting up Photoshop:

```js
var canvas = document.querySelector('canvas'),
    ctx = canvas.getContext('2d'),
    gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);

gradient.addColorStop(0, '#fff');
gradient.addColorStop(1, '#000');
ctx.fillStyle = gradient;

ctx.fillRect(0, 0, canvas.width, canvas.height);
```

{{figure 5.6

Figure 5.6 A vertical gradient on a canvas element.

}}

The code in the previous listing uses the 2D context object to generate a linear gradient object to which you can then apply colour stops. The arguments are the starting point of the gradient, x1 and y1, and the endpoint of the gradient, x2 and y2.

In this example, I'm telling the gradient to start in the top left and finish at the bottom left of the canvas. This creates a gradient that runs vertically (Figure 5.6).

Radial gradients are very similar, except the `createRadialGradient` takes the radius after each coordinate:

```js
var canvas = document.querySelector('canvas'),
    ctx = canvas.getContext('2d'),
    gradient = ctx.createRadialGradient(canvas.width/2,
    canvas.height/2, 0,
    canvas.width/2, canvas.height/2, 150);

gradient.addColorStop(0, '#fff');
gradient.addColorStop(1, '#000');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, canvas.width, canvas.width);
```

The only difference is the kind of gradient that's created. In this example, I've moved the first point of the gradient to start in the centre of the canvas starting with a radius of zero. The gradient uses a radius of 150 pixels, but notice that it also starts in the same place: `canvas.width/2`, `canvas.height/2`. This is so my example creates a smooth, circular gradient (Figure 5.7).

{{figure 5.7

Figure 5.7 This radial gradient starts and ends at the same point, but the ending radius is much greater, causing a smooth, circular gradient.

}}

Patterns are even easier to use. You need a source, and then you can drop the source element into the `createPattern` method and use the result as the `fillStyle`. The only caveat is that the element, in the case of images and videos, must have finished loading to capture the source properly.

To create the effect shown in Figure 5.8 (a tiled image across the back of the canvas), first stretch the canvas over the size of the window. Then dynamically create an image and, when it fires the load event, use the image as the source of a repeating pattern:

```js
var canvas = document.querySelector('canvas'),
    img = document.createElement('img'),
    ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

img.onload = function () {
  ctx.fillStyle = ctx.createPattern(this, 'repeat');
  ctx.fillRect(0, 0, canvas.width, canvas.height);
};

img.src = 'remysharp_avatar.jpg';
```

{{figure 5.8

Figure 5.8 Tiling an image on a canvas using the `createPattern` method.

}}

In this example I've created an image on the fly using document. `createElement`. Only after the onload event fires do I continue

to build the pattern fill. You need to wait until all the image data has loaded before you can begin to use it.

Now that the image is loaded, I'm able to set the `fillStyle` using `createPattern`. I've used `createPattern(this, 'repeat')`, and this refers to the image that fired the load event, but I can just as easily use another canvas as the source. The string 'repeat' follows the same syntax as CSS background-repeat, in that repeat-x, repeat-y, and no-repeat also work.

If you use CSS to change the canvas element's size, this will simply stretch the canvas. This doesn't actually do anything to the pixels in the canvas, only the canvas DOM node as you can see in Figure 5.9. If you were to draw something to the canvas and change the canvas element's height or width property (say you wanted to change the default 300x150 dimensions) it will blank out the contents of the canvas, and also reset the state of your drawing fill styles, stroke styles, line width, and so on. This effectively does a reset on your canvas, a trick or a problem depending on your point of view.

{{figure 5.9

Figure 5.9 When a canvas stretches after it's finished drawing, so do the contents of the canvas.

}}

## Drawing paths

{{figure 5.10

Figure 5.10 My contrived stick man drawing using the path API.

}}

Within the 2D API is a path API that allows you to move around the canvas and draw lines or shapes. The contrived example in Figure 5.10 shows a stick man drawn using the path API.

I won't take you through all the code used to produce the stick man, just the highlights so you can see what methods I used. To draw the stick man, you must specify the x, y coordinates around the canvas that you want to draw, painstakingly specifying each individual line. To draw the stick man head, run the following code:

```js
ctx.beginPath();
ctx.arc(100, 50, 30, 0, Math.PI*2, true); // head ctx.fill();
```

{{aside

# Getting from degrees to radians

The arc, bezier, and quadratic methods use radians, so if you're used to working with degrees, you'll need to convert them to radians. Here's the JavaScript you need to go from degrees to radians:

```js
var radians = degrees * Math.PI / 180;
```

It's also common to pass 360 degrees to the drawing methods, which is simply Math.PI * 2, and equally 180 degrees is Math.PI.

This gives you a solid, filled head. I've given the x, y coordinates of 100, 50, respectively, and a radius of 30 pixels. The next arguments are the start and endpoints in radians. In this example, I want a complete circle, so I start at zero and end at Math.PI*2, which is equal to 360 degrees in radians. Finally the sixth argument is the direction to draw the arc: clockwise or counterclockwise. In this case it doesn't matter, but it's still required.

}}

{{figure 5.11

Figure 5.11 An example of how a continued path causes an error in the final drawing.

}}

Once the head is drawn, I want to draw a face. The eyes and smile will be in red (well, grey in the figure). When I draw the facial features, I need to use `beginPath` again. Figure 5.11 shows what the result would be if I didn't use `beginPath`. This is because the previous arc line I drew would be included in the final face path, and because I'm starting a new arc for the mouth, as you'll see in the following code listing. I could fix the line joining the edge of the head to the mouth by using `moveTo`, which is effectively lifting the pen from the canvas to begin drawing someplace else, but I don't want the coloured outline around the head:

```js
ctx.beginPath();
// draw the smile
ctx.strokeStyle = '#c00';
ctx.lineWidth = 3;
ctx.arc(100, 50, 20, 0, Math.PI, false);

ctx.stroke();
```

The previous code listing gives me a nice semicircle for the smile with a new stroke colour and width. For the head I used fill, but for the face I need to use stroke, which will draw the line rather than a solid shape. Next the eyes:

```js
ctx.beginPath();
ctx.fillStyle = '#c00';

// start the left eye
ctx.arc(90, 45, 3, 0, Math.PI*2, true);
ctx.fill();
ctx.moveTo(113, 45);

// draw the right eye
ctx.arc(110, 45, 3, 0, Math.PI*2, true);
ctx.fill();
ctx.stroke(); // thicker eyes
```

I started a new path again, which means I can start drawing the arc for the eyes without using `moveTo` (as I did when making the smile). However, once I filled the arc, creating a solid-looking eye, I lift the pen with `moveTo(113, 45)` to draw the right eye. Notice that I moved to the right by the arc's first x coordinate plus the radius value to create a solid line, which ensures that the starting point of the arc matches where I put the pen down. Finally I use the stroke method to give the eyes a bit more thickness.

The code goes on to move the drawing point around and finally end up with an image of our stick man.

There are other path methods, which are beyond the scope of this chapter, that you can use for finer control over the lines and shapes you draw, including `quadraticCurveTo`, `bezierCurveTo`, `arcTo`, `rect`, `clip`, and `isPointInPath`.

{{aside

#Canvas and SVG: when to use which

Canvas and SVG are both very good drawing APIs, but for different reasons, and with anything, you want to use the right tool for the job. SVG is a retained-mode API, and the 2D canvas API is an immediate-mode API.

SVG maintains a tree that represents the current state of all the objects drawn onscreen, which makes it a retained-mode API. As this tree is available, it makes it a great candidate for interactivity because you can bind to specific objects in the tree and listen for click or touch events and even hit detection for games. It also has good support in desktop tools such as Adobe Illustrator and Inkscape for importing and exporting SVG graphics, rather than having to wrestle XML to create your image. SVG is vector based, so it handles scaling much better; canvas is a bitmap-based image--it doesn't scale, it just zooms.

If you need some convincing that SVG is the right tool for the job, have a look at [Raphaël](http://raphaeljs.com), the JavaScript library by Dmitry Baranovskiy. It uses SVG exclusively and is able to create some very impressive drawings and animations.

Canvas is very well suited to lots of animations and highly JavaScript-centric applications. It's a lower-level API when compared to SVG, which means that it's better for when there isn't mouse interaction because there's no tree maintaining the state of the canvas. It is good for when you have keyboard interaction, like many of the 8-bit game demos that have emerged in the last year. Since canvas is JavaScript centric, in your processing loop you can handle keyboard events on the document level. Finally, canvas is pixel orientated, as illustrated in the stick man examples in Figure 5.10, so it's good for pixel pushing.

Each of these technologies has its strengths and weaknesses. As the developer, it's your job to understand the requirements of your application and pick the right one. Good luck!

}}

## Using transformers: pixels in disguise

As well as being able to move the pen around the canvas using methods like `moveTo` and drawing shapes and lines, you can adjust what happens to the canvas under the pen using transformations.

Transformation methods include rotation, scaling, transformation, and translation (all similar to their CSS counterparts).

In Figure 5.12, I've drawn a spiral; the aim is to have it rotate in a circle, giving a quasi-Twilight Zone effect. Ideally I would keep the function that draws the spiral the same, not changing any positions, starting points, or anything else. This would keep the code much easier to manage. So to ensure that the spiral code remains simple, I can rotate the canvas under the pen, and then redraw the exact same spiral, except the result is rotated slightly in one direction.

{{figure 5.12

Figure 5.12 An animated spiral going around, and around, and around.

}}

The `rotate` method rotates from the top left (0, 0) position by default. This wouldn't do at all, and if I rotated the canvas from this position, the spiral would circulate offscreen, as if it were on a pendulum. Instead I need to rotate from the centre of the spiral, which I'll place in the centre of the canvas. Therefore I need to rotate from the centre of the canvas.

The `translate` method can help me here. It moves the 0, 0 coordinate to a new position. Figure 5.13 shows that I've drawn a dot and also shows the arguments I passed to translate. Each time translate runs it sets the new coordinates to 0, 0. Note that the translate doesn't rotate or move the canvas in a way that's presented to the user; it's translating the underlying coordinate system that subsequent drawing functions refer to.

{{figure 5.13

Figure 5.13 Example of how translate can move the origin points of the canvas.

}}

Now to achieve my rotating spiral I need to initialise the canvas using translate, and then use `setInterval` to redraw my spiral (note that `drawSpiral` is my own function, rather than a native method, that draws the path for a spiral with a series of stroke calls):

```js
ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2);
drawSpiral(); // the complicated magic mathematics
setInterval(function () {
  ctx.clearRect(
    -ctx.canvas.width/2, // x
    -ctx.canvas.height/2, // y
    ctx.canvas.width,
    ctx.canvas.height);
  ctx.rotate(Math.PI / 180 * 0.5) // 1/2 a degree
  drawSpiral();
}, 10);
```

The only caveat I have to deal with is clearing the canvas. I would normally use `clearRect(0, 0, width, height)`, but since translate has moved the 0, 0 position to the centre of the canvas, I need to manually specify the top left, as seen in the previous code listing.

## Capturing images

As well as drawing lines and shapes, you can copy images from other sources, specifically images, videos, and other canvas elements. I've already shown that you can use images as the source of a `createPattern` fill. You can also draw images straight onto your canvas. You can even crop and manipulate the images as they're copied:

```js
var ctx = document.getElementById('mycanvas').getContext('2d'),
    img = new Image();

img.onload = function () {
  ctx.canvas.height = 500;
  ctx.canvas.width = 500;
  ctx.drawImage(this, 10, 10, 100, 100, 0, 0, 500, 500);
};

img.src = 'bruce-and-remy-promo-pics.jpg';
```

> All 2D drawing contexts have a back reference to the canvas which they draw against. This means you don't have to pass around two variables to functions, you can just pass the context and get the back reference to the canvas element if you wanted to change the height, width, or get the data url.

The code above is a simple example of how I can dynamically create an image on the fly, and once it's loaded I can draw a section of it in to my canvas. As we'll see in a moment you have a few ways of using the `drawImage` method, and here what I've done is take a 100x100 pixel crop from 10 pixels left and 10 pixels right, and stretch it in to the canvas over 500 pixels wide and tall.

Since you can also capture an image from a video element, this makes for some interesting opportunities. There's already lots of demos out in the wild, showing some interesting effects like dynamically injecting content into video, green screen replacement for video, and facial recognition--all using combinations of canvas and video, all written in JavaScript.

The capturing and drawing is done entirely through the `drawImage` method, which needs a reference to the source (an image, video, or canvas element), a target position (the top/left coordinates of where you want to draw the image in your canvas), and a few optional arguments that allow you to crop and scale the image:

- `drawImage(image, dx, dy)`
- `drawImage(image, dx, dy, dw, dh)`
- `drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)`

where d is the destination position and s is the source. For example, if I took Bruce's synergy video from Chapter 4, and wanted to run a repeating thumbnail of him bashing the banana across the top of my website, I could do it by drawing a cropped and scaled version of the video using the `drawImage` method.

The components I need are:

- A canvas fixed across the top of my site
- A hidden video running the synergies video
- A way to loop just the bit of the video I want
- A method to capture what's on the video and transfer it to the canvas
The reason I'm using a hidden video is because this will be the source for my canvas, but I don't want it to be seen. I just want to keep grabbing the video frame and putting it on the canvas.

I just want the part of Bruce smashing the banana with the mallet (the part from 0:49 to 0:52), so I need to tell the video to play only that part. There's no content attribute I can use to tell it to start from a particular point, so I'll just force the `currentTime` to second 49. Then on the timeupdate event, I'll force the `currentTime` back to 49 if it goes above 52 seconds. So my time range is the window of 49 to 52 seconds in the video. Due to some browsers trying to hold back data and missing support for the video.seekable property, for this example I'll use a timer to try to force the start time:

```js
var jumpTimer = setInterval(function () {
  try {
    // if the data isn't available, setting currentTime will throw an error
    video.currentTime = start;
    clearInterval(jumpTimer);
    video.play();
  } catch (e) {}
}, 100);

video.addEventListener('timeupdate', function () {
  if (this.currentTime > 52) this.currentTime = 49;
}, false);
```

The previous code keeps trying to set the `video.currentTime` value, but doing so before the video data is ready throws a JavaScript error. If the error is thrown, the code doesn't reach `clearInterval`. If successful, the `setInterval` is cleared and the video is played.

Now that the video loop is in place, I can start grabbing frames from the video element. I could use the timeupdate event to draw the canvas, but I know that the effect doesn't perform anywhere nearly as well as if I run the canvas drawing in its own timer. I could speculate that this is because the browser is trying to do the hard work to render the video element; separating it in a timer gives the browser some room to breathe.

Once the loadeddata event fires on the video, I'll initialise the canvas so it's the same width as the window (otherwise our image would stretch, as you saw in Figure 5.9). Then I'll mute the video (to avoid being too annoying!) and calculate the shortest edge because I want to crop a square from the video and repeat it across the canvas:

```js
video.addEventListener('loadeddata', function () {
  var size = 78; // thumbnail size
  canvas.width = window.innerWidth;
  video.volume = 0;
  shortestEdge = video.videoHeight > video.videoWidth ? video.videoWidth :
video.videoHeight;

  // kick off our drawing loop
  setInterval(function () {
    // arguments have been broken into multi lines
    for (var i = 0, w = canvas.width; i < w; i += size) {
       ctx.drawImage(
         video,
        (video.videoWidth - shortestEdge)/2, // sx
        (video.videoHeight - shortestEdge)/2, // sy
        shortestEdge, // sw
        shortestEdge, // sh
        i, // dx
        0, // dy size, // dh size // dy
      );
    }
  }, 67); // 67 is approximately 15fps
}, false);
```

All the magic happens inside the `setInterval`, which triggers every 67/1000th of a second (JavaScript measures seconds by 1000 milliseconds; therefore 1000 milliseconds/15 frames per second = about 67, or approximately 15 fps--equally 25fps would be 1000/25), which should be good enough for faking video playback. Once inside the `setInterval`, I'll loop over the width of the canvas, incrementing by the size of the thumbnail I'm drawing to fill the canvas horizontally.

{{figure 5.14

Figure 5.14 A visual representation of arguments passed to `drawImage`.

}}

The mapping for the arguments to the `drawImage` method is shown in Figure 5.14.

Using a simple crop for the height and width, and using the shortest edge, I can then easily scale the crop to the thumbnail size and let the canvas do all the hard work for me. The result: Bruce bashing a banana across the top of my site (Figure 5.15).

{{figure 5.15

Figure 5.15 An animated banner across my site using canvas and video.

}}

## Pushing pixels

One very cool feature of the canvas API is its ability to interrogate individual pixels, something that isn't possible with SVG, which is vector-based, and not really aimed at pixel-level operations. You can get every pixel from the 2D context object broken down into four colour channels: red, green, blue, and the alpha transparency channel (rgba). For example:

```js
var ctx = document.querySelector('canvas').
getContext('2d'),
img = document.createElement('img');
// wait until the image has loaded to read the data img.onload = function () {
ctx.drawImage(img, 0, 0);
var pixels = ctx.getImageData(0, 0, img.width,
img.height);
};
```

The variable pixels is a `CanvasPixelArray`, which contains the `height`, `width`, and `data` properties. `data` is an array of the pixel data, which is made up as follows:

```js
[ r1, g1, b1, a1, r2, g2, b2, a2, r3, g3, b3, a3, ... ]
```

> To use the source of another image in the `drawImage` method, it must be served through http (not a local file system).

Where `r1`, `g1`, `b1`, `a1` makes up the first pixel, `r2`, `g2`, `b2`, `a2` makes up the second pixel, and so on. This means that data. length is the number of pixels captured from the `getImageData` (in the previous example this will be the same size as the image) multiplied by 4, as there are 4 channels to each pixel. Note that the pixel arrangement in the `CanvasPixelArray` is from top-left to bottom-right, going row by row for the area selected.

Since you have access to this data, you can do pixel-level processing. So you could create custom image filters for applications like the image editors shown in Figure 5.2 or perhaps scan the image for particular colour ranges or even write a web app that does facial recognition.

Paul Rouget and Tristan Nitot of Mozilla showed off a demo early in 2009 (see Figure 5.16) that uses a video drawn onto a canvas and injects dynamic content on top of it. As each video frame

is drawn on the canvas, the pixel data is read and searched for a solid block of white (where the pixel is 255, 255, 255), which is used as an anchor point to draw another visual element on the canvas. In Figure 5.16, another canvas element has been dynamically injected. You can play with the [demo here](http://people.mozilla.com/~prouget/demos/DynamicContentInjection/play.xhtml).

{{figure 5.16

Figure 5.16 Scanning a video for bright pixels to inject dynamic content.

}}

In the following code example, I load an image into the canvas and invert all the pixels, creating a strange X-ray version of Bruce and me (Figure 5.17):

> For security, the canvas element contains an internal origin-clean flag that's set to true by default. This flag will flip to false if an image or video is used whose origin does not match that of the document that owns the canvas. The same goes for using a canvas as an image source if it already has the origin-clean flag set to false. If the flag is false, you won't be able to use the `getImageData` or `toDataURL` methods. This remains the case even if you change the size of your canvas or draw on the canvas after the flag is set to false.

```js
var ctx = document.querySelector('canvas').getContext('2d'),
    img = document.createElement('img');

// wait until the image has loaded
img.onload = function () {
  ctx.canvas.width = img.width;
  ctx.canvas.height = img.height;
  ctx.drawImage(img, 0, 0);

  var pixels = ctx.getImageData(0, 0, img.width, img.height);

  for (var i = 0, n = pixels.data.length; i < n; i += 4) {
    pixels.data[i+0] = 255 - pixels.data[i+0]; // red
    pixels.data[i+1] = 255 - pixels.data[i+2]; // green
    pixels.data[i+2] = 255 - pixels.data[i+1]; // blue
    // i + 3 is the alpha channel which we don't need
  }

  ctx.putImageData(pixels, 0, 0);
};

img.src = 'authors.jpg';
```

In the previous code listing, I wait until the image has loaded before trying to copy it to the canvas. I draw it into the canvas and immediately read out the pixel data to invert the image.

In the for loop, I'm using `i += 4`, which ensures I'm iterating over each pixel and not the pixel channels. By setting the pixel bit to 255 minus the current value, I get an inverted colour.

Finally, I put the modified pixels back into the canvas using `putImageData`, passing in the `CanvasPixelArray` object and the x/y start point.

{{figure 5.17

Figure 5.17 If you were to X-ray Bruce and Remy, you'd see they look just as strange.

}}

### Saving to file


You've made the next best thing since sliced bread? Want to save your beautiful drawing to your desktop? You want to export it in multiple formats? No problem. Canvas has you covered.

The canvas element (not the 2D context) supports exporting the current state of the canvas to a data URL.

{{aside

  # What's a data URL?

Most browsers support Base64 encoded assets, such as an image. Web applications like Gmail use Base64 encoded images in their CSS to reduce the number of requests being made over the wire (even though it actually makes the CSS file larger as all the image data is embedded). The URL scheme looks like this:

[`data:image/png;base64](`data:image/png;base64),iVBORw0KGgoAAAANSUhEUgAAAAoAAAAK...`

It starts with data, then the mime type, then the encoding, Base64, and then the raw data (which roughly speaking is 30 percent larger than the source image). This raw data is what's exported by the canvas element, and browsers are able to decode the data in to real assets (sadly, this doesn't include IE7 or previous incarnations of IE). In addition, IE8 only supports data URLs up to a length of 32KB--something to watch out for!

}}

Exporting is very easy. The canvas has the `toDataURL` method, which can be invoked with the format in which you want your image. Only PNG support is required by the canvas specification, but browsers can support other types if they choose. For example, Safari supports GIF, PNG, and JPG. Trying to get the data URL for an unsupported TIFF format returns exclusively the letter A multiple times and no `data:<mime-type>`. Opera supports only PNG, but on requesting a JPG or GIF, it still returns

a PNG (ignoring the file format). Old versions of Firefox (on a Mac) supported only PNG, throwing an error on all other types (which was a little severe if you ask me). The lesson here is that once you have your data URL back, ensure that it starts with *`data:<your-mime-type>`* to ensure that they match up and that you get back the image in the format you asked for.

The following example generates a drawing similar to our *hello world* example and immediately saves it to a PNG by redirecting the browser to the rendered data URL:

```
var ctx = document.querySelector('canvas').getContext('2d');
ctx.fillStyle = 'rgb(0, 0, 255)';
ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
ctx.fillStyle = 'rgb(0, 255, 0)';
ctx.fillRect(10, 20, 50, 50); // little square
window.location = ctx.canvas.toDataURL('image/png');
```

Finally, the `toDataURL` also takes an optional second argument that is available only if image/jpg has been implemented to allow you to specify the quality level of the generated image. This value would be between 0.0 and 1, with 1 being the highest quality available--but be careful, as this will affect the size of the final image, and, in our case, the size of the Base64 data string generated by the `toDataURL` method.

## Animating your canvas paintings

You've seen some basic animations using canvas throughout this chapter, but I wanted to explain some of the concepts in detail here.

Simple animation is mostly about clearing the current canvas state and drawing the whole thing again. This is very quick to do, as the canvas is a native drawing API. I'll show you a demo that takes Bruce's bouncy head and bounces it around the canvas area. This example is based on the canvas breakout tutorial by Bill Mill, but I jazzed it up with Bruce's mug bouncing instead of a solid black ball.

{{aside

# The Processing JavaScript Library

As you'll find out, it's a blast to navigate around the canvas with a pen drawing lines and filling shapes, but there are already some libraries available that make working with the canvas much easier. One such library is called [processing.js](http://processingjs.org/), written by the author of jQuery, John Resig.

It's not actually a library designed to ease working with canvas, but it in fact interprets the Processing language in JavaScript, which is in turn drawn on the canvas element. In many ways, processing.js is a great tool for visualisation and abstracts away a lot of the more complicated drawing and animation procedures in the 2D drawing API.



}}

The code used for Figure 5.18 is relatively simple and breaks down as follows:

1. Initialise the canvas and objects you want to draw.

2. Clear the canvas.

3. Draw the ball on the canvas.

To add extra spice, I rotate Bruce's face in circles whilst he bounces around. So I'll have to do some rotation on the canvas, too.

{{figure 5.18
Figure 5.18 While away the hours whilst you watch Bruce's face bounce around a canvas animation.
}}

Since I'm going to rotate Bruce's face, I'll let another canvas handle that task (so I can keep my main canvas free from rotation and translations). This keeps my tasks simple in that I'm rotating an image of Bruce in one canvas while I'm working out the position of his face and drawing in the second.

```js
var ctx = document.querySelector('canvas').getContext("2d"),
    ballctx,
    x = 100, // arbitrary start points
    y = 50,
    dx = 2,
    dy = 4,
    width = ctx.canvas.width,
    height = ctx.canvas.height;

// load the image
ballImg = document.createElement('img');

ballImg.src = 'bruce-ball.png';

// once loaded, start the ball bouncing
ballImg.onload = function () {
  var ball = document.createElement('canvas');
  ball.height = 50;
  ball.width = 50;
  ballctx = ball.getContext('2d');

  // translate to centre to rotate properly
  ballctx.translate(25, 25);
  setInterval(draw, 10);
};

function draw() {
  ctx.clearRect(0, 0, width, height);
  ballctx.rotate(Math.PI/180*5); // 5 degrees

  // draw at the 0,0 position
  ballctx.drawImage(ballImg, 0, 0, ballImg.width, ballImg.height, -25, -25, 50, 50);

  // copy the rotated source
  ctx.drawImage(ballctx.canvas, x, y);

  if (x + dx > width || x + dx < 0) dx = -dx;
  if (y + dy > height || y + dy < 0) dy = -dy;

  x += dx;
  y += dy;
}
```

All the action is happening in the draw function, but only after I've finished setting up. In the setup, the code dynamically creates a new canvas for the ball but doesn't put it inside the DOM. This canvas is then translated so the rotation of Bruce's face happens in the centre of the canvas. I can still use the 2D context of this "unattached" canvas and I explicitly give this canvas a height and width (otherwise it's automatically set to 300x150px).

The draw function then runs every 1/100th of a second (10 milliseconds), constantly incrementing the x and y position and redrawing the ball canvas on the main canvas, but not before the blanket clearing of the canvas with `ctx.clearRect(0, 0, width, height)`, which is effectively resetting the entire effect.

So that's it. Animation. Probably most akin to a flip-book animation.

### Saving and restoring drawing state

There is a little more hope built into the 2D API: drawing state. There are two methods on the context object: save and restore, which manage the current stack of drawing states. The save method pushes the current state on to the stack, whereas restore pops from the top of the stack.

Drawing states don't cover everything you do to the canvas, but they do include the following:

- Transformations
- Clipping regions (not covered in this book)
- Current values for the following attributes: `fillStyle`, `font`, `globalAlpha`, `globalCompositeOperation`, `lineCap`, `lineJoin`, `lineWidth`, `miterLimit`, `shadowBlur`, `shadowColor`, `shadowOffsetX`, `shadowOffsetY`, `strokeStyle`, `textAlign`, and `textBaseline`.

> Save and restore do not affect the current paths or current bitmap on the canvas (you can't restore to a previous state of the image on the canvas).

For example, the following code snippet from the Mozilla canvas composition tutorial shows how it would draw 50 stars on a canvas in random positions. It sets the position using the translate method. But at the end of each iteration of the loop, it restores the original state of the canvas, thus moving the top/left of the canvas to the real top left, rather than the position of the last translate:

```js
for (var j=1; j<50; j++) {
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.translate(75-Math.floor(Math.random()*150),
                75-Math.floor(Math.random()*150));
  drawStar(ctx,Math.floor(Math.random()*4)+2);
  ctx.restore();
}
```

### Rendering text

`canvas` allows you to render text and specify fonts, sizes, alignment, and baselines. You can also fill text (as normal text might appear) and stroke text (around the outline). The old Bespin project was a great example of how custom text rendering can be used to create a fully functional code editor written entirely with the canvas API (it's since been superceded by Ace by the nice folks at Ajax.org--but their version doesn't use a canvas).

Drawing text requires the string and coordinates. For example, to show you how to use translate, I used an annotated canvas (shown in Figure 5.19 and earlier in Figure 5.13). I used `fillText` to annotate the new centre point of the canvas to label the dots I had placed around the canvas (whose height and width are hard coded to 300x300 for this example):

```js
function dot(string) {
  ctx.beginPath();
  ctx.arc(0,0,5,0,Math.PI*2,true); // draw
  circle ctx.fill();
  ctx.fillText(string, 5, 10); // render text
}
```

Now I can translate the canvas and call the dot function, passing

the string I want printed next to the dot:

```js
dot('1. no translate'); // show dot

ctx.translate(150, 150);
dot('2. (150, 150)'); // show dot

ctx.translate(-100, 20);
dot('3. (-100, 20)'); // show dot
```

{{figure 5.19
Figure 5.19 Using `fillText` to annotate a canvas.
}}

By default, the `fillText` method uses a 10 pixel tall sans serif as the selected font. You can change this to your own font style by setting the font property on the context using the same syntax as CSS fonts (for example, `ctx.font = 'italic 400 12px/2 helvetica neue, sans-serif'`). You can even use CSS3 web fonts, provided they've been fully loaded before you use them. When I call `fillText`, the text rendering uses the same `fillStyle` that I set earlier (or uses the canvas default). Equally `strokeText` uses the current `strokeStyle`.

### Accessibility within the canvas element

> JIT means Just in Time compilation, a technique used to improve the runtime performance of a program.

One reason that canvas is so fast on today's optimised JIT JavaScript interpreters is that it keeps no DOM: it really is just

a big bunch of pixels, with no information stored about which geometric shapes, text, or images have been thrown at them (compare this to SVG, which does maintain all those as separate objects in a DOM structure). So, for example, if you need any kind of collision detection, you need to do all the bookkeeping yourself. There is no representation of what objects have been drawn that JavaScript can interrogate.

This also causes difficulty for accessibility. If your games are keyboardand mouse-accessible, that goes a long way to meeting the needs of many. But for users with visual impairments, there is nothing for assistive technology to hook into. Canvas text is the same: bringing text into canvas means it ceases to

be text and is just pixels. It's even worse than `<img>` because at least that can take alt text. Although the contents of the element (the text between the canvas tags) can be changed with script to reflect the canvas text you're inserting with JavaScript, I'm not optimistic that developers will do this.

> Filament Group's jQuery Visualize plugin uses jQuery to inject a canvas element to a page that graphs the information from a data table in the markup. Assistive technologies have access to the raw data table, while the information is supplemented with visual graphs for sighted users.

An accessibility task force of the Working Group is looking at ways to enhance the accessibility of canvas. It's not impossible: Flash 5 managed to add accessibility features. However, I recommend that, for the time being, canvas not be used for user interfaces or as the only way to communicate information. Filament Group's jQuery Visualize plugin is a good example of canvas being used to supplement accessible information (see Note).

## Summary

The canvas API finally gives developers the ability to dynamically generate and manipulate graphics client-side, directly in the browser, without the need for plugin-based detours via Flash and Co. The canvas is especially powerful for pixel-level processing, and I can imagine that canvas-based applications will be pushing the boundaries of what we've historically seen on the Web.

However, you should be careful to choose the right technology for the job. Consider SVG before ploughing ahead with your next Awesome 3.0 app. And watch out for the possible accessibility implications.